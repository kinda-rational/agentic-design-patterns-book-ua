# Додаток E - ШІ Агенти на CLI

## Вступ

Командна строка розробника, давно бувши твердинею точних, імперативних команд, претерпівають глибоку трансформацію. Вона еволюціонує від простої оболонки до інтелектуального, спільного рабочого простору, керованого новим класом інструментів: ШІ Agent Command-Line Interfaces (CLIs). Ці агенти виходять далеко за межи простого виконання команд; вони розуміють природну мову, підтримують контекст про всю вашу кодову базу та можуть виконувати складні багатоетапні завдання, автоматизуючи значні частини життєвого циклу розробки.

Цей посібник забезпечує глибокий погляд на чотирьох провідних гравців у цій, що зароджується, галузі, досліджуючи їхні унікальні сильні сторони, ідеальні випадки використання та різні філософії, щоб допомогти вам визначити, який інструмент найкраще підходить для вашого рабочого процесу. Важливо відзначити, що багато прикладів випадків використання, надані для конкретного інструменту, часто можуть бути виконані іншими агентами. Ключова різниця між цими інструментами часто полягає в якості, ефективності та нюансах результатів, які вони можуть досягти для даного завдання. Існують спеціальні тести, призначені для вимірювання цих можливостей, які будуть обговорені в наступних розділах.

## Claude CLI (Claude Code)

Claude CLI від Anthropic розроблений як високорівневий агент кодування з глибоким, цілісним розумінням архітектури проекту. Його основна сила полягає в його "агентній" природі, дозволяючи створювати ментальну модель вашого репозиторію для складних багатоетапних завдань. Взаємодія є дуже розмовною, нагадуючи сесію парного програмування, де він пояснює свої плани перед виконанням. Це робить його ідеальним для професійних розробників, що працюють над крупномасштабними проектами, які включають значний рефакторинг або реалізацію функцій з широким архітектурним впливом.

**Приклади випадків використання:**

1. **Крупномасштабний рефакторинг:** Ви можете дати йому вказівку: "Наша поточна автентифікація користувачів покладається на сесійні файли cookie. Рефакторуйте всю кодову базу для використання stateless JWTs, оновивши точки входу/вихід, middleware та обробку токенів на фронтенді." Claude потім прочитає всі відповідні файли та виконає скоординовані зміни.

2. **Інтеграція API:** Після надання специфікації OpenAPI для нового сервісу прогнозу погоди, ви можете сказати: "Інтегруйте цей новий API прогнозу погоди. Створіть модульний сервіс для обробки викликів API, додайте новий компонент для відображення прогнозу та оновіть головну панель, щоб її включити."

3. **Генерування документації:** Вказуючи на складний модуль з погано задокументованим кодом, ви можете запитати: "Проаналізуйте файл `./src/utils/data_processing.js`. Сгенеруйте комплексні TSDoc коментарі для кожної функції, пояснюючи її призначення, параметри та повернене значення."

Claude CLI функціонує як спеціалізований помічник з кодування з вбудованими інструментами для основних завдань розробки, включаючи абсорбування файлів, аналіз структури коду та генерування виправлень. Його глибока інтеграція з Git спрощує пряме керування гілками та коммітами. Розширюваність агента опосередкована Multi-tool Control Protocol (MCP), дозволяючи користувачам визначати та інтегрувати користувацькі інструменти. Це дозволяє взаємодіяти з приватними API, запитами до бази даних та виконанням спеціалізованих для проекту скриптів. Ця архітектура позиціонує розробника як арбітра функціональної область агента, ефективно характеризуючи Claude як рушій міркування, посилений користувацькими інструментами.

## Gemini CLI

Gemini CLI від Google — це універсальний, відкритий ШІ-агент, розроблений для потужності та доступності. Він виділяється передовою моделлю Gemini 2.5 Pro, масивним контекстним вікном та мультимодальними можливостями (обробка зображень та тексту). Його відкрита природа, щедрий безплатний рівень та цикл "Міркуй та Дій" роблять його прозорим, контрольованим та чудовим універсальним рішенням для широкої аудиторії, від ентузіастів до корпоративних розробників, особливо тих, хто знаходиться в екосистемі Google Cloud.

**Приклади випадків використання:**

1. **Мультимодальна розробка:** Ви надаєте снімок екрана веб-компонента з файлу дизайну (`gemini describe component.png`) та даєте вказівку: "Напишіть HTML та CSS код для створення React компонента, який виглядає точно так само. Переконайтеся, що він адаптивний."

2. **Керування хмарними ресурсами:** Використовуючи його вбудовану інтеграцію з Google Cloud, ви можете командувати: "Знайдіть всі кластери GKE в проекті `production`, які працюють на версіях старших за 1.28, та сгенеруйте команду `gcloud` для їхнього послідовного оновлення."

3. **Інтеграція корпоративних інструментів (через MCP):** Розробник надає Gemini користувацький інструмент під назвою `get-employee-details`, який підключається до внутрішнього HR API компанії. Промпт: "Складіть вітальний документ для нашого нового співробітника. Спочатку використайте інструмент `get-employee-details --id=E90210` для отримання його імені та команди, а потім заповніть `welcome_template.md` цією інформацією."

4. **Крупномасштабний рефакторинг:** Розробнику потрібно рефакторити велику Java кодову базу для заміни застарілої бібліотеки логування на нову структуровану систему логування. Вони можуть використовувати Gemini з промптом типу: "Прочитайте всі *.java файли в директорії 'src/main/java'. Для кожного файлу замініть усі приклади імпорту 'org.apache.log4j' та його класу 'Logger' на 'org.slf4j.Logger' та 'LoggerFactory'. Перепишіть ініціалізацію логгера та всі виклики .info(), .debug() та .error() для використання нового структурованого формату з парами ключ-значення."

Gemini CLI оснащена набором вбудованих інструментів, які дозволяють їй взаємодіяти з її оточенням. До них відносяться інструменти для операцій з файловою системою (таких як читання та запис), інструмент оболонки для виконання команд та інструменти для доступу в інтернет через веб-запити та пошук. Для більш широкого контексту вона використовує спеціалізовані інструменти для одночасного читання кількох файлів та інструмент пам'яті для збереження інформації для наступних сесій. Ця функціональність побудована на безпечній основі: піщаниця ізолює дії моделі для запобігання ризикам, тоді як MCP сервери діють як міст, дозволяючи Gemini безпечно підключатися до вашого локального середовища або іншим API.

## Aider

Aider — це відкритий помічник з ШІ-кодування, який діє як справжній парний програміст, працюючи безпосередньо з вашими файлами та коммітячи зміни в Git. Його визначальна особливість — це його прямолінійність; він застосовує виправлення, запускає тести для їхної валідації та автоматично коммітить кожну успішну зміну. Будучи агностичним до моделі, він дає користувачам повний контроль над вартістю та можливостями. Його git-центричний рабочий процес робить його ідеальним для розробників, які цінують ефективність, контроль та прозорий, перевіримий слід всіх модифікацій коду.

**Приклади випадків використання:**

1. **Розробка через тестування (TDD):** Розробник може сказати: "Створіть недослідний тест для функції, яка обчислює факторіал числа." Після того, як Aider напише тест та він впаде, наступний промпт: "Тепер напишіть код, щоб тест пройшов." Aider реалізує функцію та знову запускає тест для підтвердження.

2. **Точне виправлення багів:** Враховуючи звіт про помилку, ви можете дати Aider вказівку: "Функція `calculate_total` в `billing.py` не працює у високосні роки. Додайте файл до контексту, виправте баг та перевірте ваше виправлення проти існуючого набору тестів."

3. **Оновлення залежностей:** Ви можете дати їй вказівку: "Наш проект використовує застарілу версію бібліотеки 'requests'. Будь ласка, пройдіться по всіх Python файлах, оновіть оператори імпорту та будь-які застарілі виклики функцій для сумісності з останньою версією, а потім оновіть `requirements.txt`."

## GitHub Copilot CLI

GitHub Copilot CLI розширює популярного помічника з ШІ-парного програмування в терміна, з його основною перевагою в рідній, глибокій інтеграції з екосистемою GitHub. Він розуміє контекст проекту _в межах GitHub_. Його агентні можливості дозволяють йому бути призначеним на GitHub issue, працювати над виправленням та відправляти pull request для людського обзору.

**Приклади випадків використання:**

1. **Автоматичне розв'язання проблем:** Менеджер призначає тікет з багом (наприклад, "Issue #123: Виправити помилку off-by-one у пагінації") агенту Copilot. Агент потім створює нову гілку, пише код та відправляє pull request, посилаючись на issue, все без ручного втручання розробника.

2. **Інформована про репозиторій Q&A:** Новий розробник в команді може запитати: "Де в цьому репозиторії визначена логіка підключення до бази даних та які змінні середовища вона потребує?" Copilot CLI використовує свою обізнаність про все репо для надання точної відповіді з шляхами до файлів.

3. **Помічник по командам оболонки:** Коли не впевнені в складній команді оболонки, користувач може запитати: `gh? find all files larger than 50MB, compress them, and place them in an archive folder`. Copilot згенерує точну команду оболонки, необхідну для виконання завдання.

## Terminal-Bench: Тест для ШІ агентів в командних інтерфейсах

Terminal-Bench — це нова система оцінки, призначена для оцінки майстерності ШІ-агентів у виконанні складних завдань в межах командного інтерфейсу. Терміна визначається як оптимальне оточення для роботи ШІ-агентів завдяки його текстовому, ізольованому характеру. Перший випуск, Terminal-Bench-Core-v0, включає 80 вручну підібраних завдань, що охоплюють такі області, як наукові рабочі процеси та аналіз даних. Для забезпечення справедливих порівнянь був розроблений Terminus, мініміалістичний агент, для служіння стандартизованому тестовому стенду для різних мовних моделей. Фреймворк розроблений для розширюваності, дозволяючи інтеграцію різноманітних агентів через контейнеризацію або прямі з'єднання. Майбутні розробки включають включення масово паралельних оцінок та інтеграцію встановлених тестів. Проект заохочує відкриті вклади для розширення завдань та спільного покращення фреймворку.

## Висновок

Поява цих потужних ШІ командних агентів означає фундаментальний зсув у розробці програмного забезпечення, трансформуючи терміна в динамічне та спільне оточення. Як ми бачили, немає єдиного "кращого" інструменту; замість цього формується яскрава екосистема, де кожен агент пропонує спеціалізовану силу. Ідеальний вибір повністю залежить від потреб розробника: Claude для складних архітектурних завдань, Gemini для універсального та мультимодального вирішення проблем, Aider для git-центричного та прямого редагування коду та GitHub Copilot для бездоганної інтеграції в GitHub рабочий процес. По мірі того, як ці інструменти продовжують еволюціонувати, майстерність у їхньому використанні стане важливою навичкою, фундаментально змінюючи те, як розробники створюють, налагоджують та керують програмним забезпеченням.

## Посилання

1. [Anthropic. _Claude_](https://docs.anthropic.com/en/docs/claude-code/cli-reference)
2. [Google Gemini CLI](https://github.com/google-gemini/gemini-cli)
3. [Aider](https://aider.chat/)
4. [GitHub Copilot CLI](https://docs.github.com/en/copilot/github-copilot-enterprise/copilot-cli)
5. [Terminal Bench](https://www.tbench.ai/)

---

## Навігація

**Назад:** [Додаток D. Створення агента з AgentSpace](Додаток%20D.%20Створення%20агента%20з%20AgentSpace.md)
**Вперед:** [Додаток F. Під капотом: погляд всередину на механізми міркування агентів](Додаток%20F.%20Під%20капотом:%20погляд%20всередину%20на%20механізми%20міркування%20агентів.md)
