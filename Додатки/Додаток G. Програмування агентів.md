# Додаток G - Програмування агентів

## Vibe Coding: відправна точка

"Vibe coding" став потужною технікою для швидкого інноваційного розвитку та творчого дослідження. Ця практика передбачає використання LLM для генерування первинних набросків, створення схем складної логіки або побудови швидких прототипів, значно знижуючи первинне тертя. Це безцінно для подолання проблеми "чистого аркуша", дозволяючи розробникам швидко переходити від розмитої концепції до осяжного, виконуваного коду. Vibe coding особливо ефективний при дослідженні незнайомих API або тестуванні нових архітектурних паттернів, оскільки він обходить невідкладну потребу в ідеальній реалізації. Згенерований код часто виступає як творчий каталізатор, надаючи основу для розробників, щоб критикувати, рефакторувати та розширювати його. Його основна сила полягає в здатності прискорити первинні фази відкриття та генерування ідей у життєвому циклі програмного забезпечення. Однак, хоча vibe coding виділяється в мозковому штурмі, розробка надійного, масштабованого та підтримуваного програмного забезпечення вимагає більш структурованого підходу, переходячи від чистої генерації до спільного партнерства зі спеціалізованими агентами програмування.

## Агенти як члени команди

Хоча перша хвиля була зосереджена на сирій генерації коду — "vibe code", ідеальному для генерування ідей — індустрія тепер переходить до більш інтегрованої та потужної парадигми для виробничої роботи. Найбільш ефективні команди розробки не просто делегують завдання агентам; вони доповнюють себе набором складних агентів програмування. Ці агенти діють як невтомні, спеціалізовані члени команди, посилюючи людську креативність та значно збільшуючи масштабованість та швидкість команди.

Ця еволюція відображається у заявах лідерів індустрії. На початку 2025 року генеральний директор Alphabet Сундар Пічаї зазначив, що в Google "понад 30% нового коду тепер створюється або генерується за допомогою наших моделей Gemini, фундаментально змінюючи нашу швидкість розробки". Microsoft зробила аналогічну заяву. Цей відраслевий зсув сигналізує про те, що справжня границя полягає не в заміні розробників, а в їхньому розширенні можливостей. Метою є доповнена взаємодія, де люди направляють архітектурне бачення та творче вирішення проблем, тоді як агенти обробляють спеціалізовані, масштабовані завдання, такі як тестування, документація та огляд.

Цей розділ представляє фреймворк для організації команди людина-агент, заснований на основній філософії, що розробники-люди діють як творчі лідери та архітектори, тоді як AI агенти функціонують як посилювачі сили.

Цей фреймворк базується на трьох основоположних принципах:

1. **Оркестрування під керуванням людини:** Розробник є лідером команди та архітектором проекту. Він завжди в контурі, оркеструючи рабочий процес, встановлюючи високорівневі цілі та приймаючи остаточні рішення. Агенти потужні, але вони допоміжні співробітники. Розробник направляє, який агент залучити, надає необхідний контекст та, що найважливіше, здійснює остаточне судження про будь-якій вихід, згенерований агентом, забезпечуючи його відповідність стандартам якості проекту та довгостроковому баченню.

2. **Пріоритет контексту:** Продуктивність агента повністю залежить від якості та повноти його контексту. Потужний LLM з поганим контекстом непридатний. Тому наш фреймворк приоритизує ретельний, керований людиною підхід до курування контексту. Автоматизований, чорний ящик витяг контексту уникається. Розробник відповідає за складання ідеального "брифінгу" для свого члена команди-агента. Це включає:

   - **Повна кодова база:** Надання всього відповідного вихідного коду, щоб агент розумів існуючі паттерни та логіку.
   - **Зовнішні знання:** Постачання конкретної документації, визначень API або документів проекту.
   - **Людський брифінг:** Чітке формулювання цілей, вимог, описів pull request та посібників стилю.

3. **Прямий доступ до моделі:** Для досягнення результатів світового класу агенти повинні забезпечити прямий доступ до крайніх моделей (наприклад, Gemini 2.5 PRO, Claude Opus 4, OpenAI, DeepSeek тощо). Використання менш потужних моделей або маршрутизація запитів через посередницькі платформи, які приховують або скорочують контекст, знизить продуктивність. Фреймворк побудований на створенні максимально чистого діалогу між людським лідером та сирими можливостями базової моделі, забезпечуючи роботу кожного агента на піку його потенціалу.

Фреймворк структурирован як команда спеціалізованих агентів, кожен з яких призначений для основної функції в життєвому циклі розробки. Людина-розробник діє як центральний оркестратор, делегуючи завдання та інтегруючи результати.

## Основні компоненти

Для ефективного використання крайньої Large Language Model цей фреймворк призначає різні ролі розробки команді спеціалізованих агентів. Ці агенти — це не окремі додатки, а концептуальні персонажі, викликаючись в LLM через ретельно створені, спеціалізовані для ролі промпти та контексти. Цей підхід забезпечує точний фокус оширених можливостей моделі на поставленому завданні, від написання первинного коду до виконання нюансованого, критичного огляду.

**Оркестратор: Людина-розробник:** У цьому спільному фреймворку людина-розробник діє як Оркестратор, служачи центральним інтелектом та остаточною владою над AI агентами.

- **Роль:** Лідер команди, архітектор та остаточний особа, що приймає рішення. Оркестратор визначає завдання, готує контекст та перевіряє всю роботу, виконану агентами.
- **Інтерфейс:** Власний терміна розробника, редактор та рідний веб-інтерфейс вибраних агентів.

**Область підготовки контексту:** Як основа для будь-якої успішної взаємодії з агентом, Область підготовки контексту — це місце, де людина-розробник ретельно готує повний та специфічний для завдання брифінг.

- **Роль:** Виділена рабоча область для кожного завдання, забезпечуючи отримання агентами повного та точного брифінгу.
- **Реалізація:** Тимчасова директорія (task-context/) що містить markdown файли для цілей, файли коду та відповідні документи

**Спеціалізовані агенти:** Використовуючи цільові промпти, ми можемо побудувати команду спеціалізованих агентів, кожен з яких адаптований до конкретного завдання розробки.

- **Агент-будівельник: Реалізатор**

  - **Мета:** Пише новий код, реалізує функції або створює шаблонний код на основі детальних специфікацій.
  - **Промпт виклику:** "Ви — старший інженер-програміст. На основі вимог у 01_BRIEF.md та існуючих паттернів у 02_CODE/, реалізуйте функцію..."

- **Агент-тестувальник: Страж якості**

  - **Мета:** Пише комплексні модульні тести, інтеграційні тести та end-to-end тести для нового або існуючого коду.
  - **Промпт виклику:** "Ви — інженер з забезпечення якості. Для коду, надане у 02_CODE/, напишіть повний набір модульних тестів, використовуючи [Testing Framework, наприклад, pytest]. Покрийте всі граничні випадки та дотримуйтеся філософії тестування проекту."

- **Агент-документатор: Писар**

  - **Мета:** Генерує чітку, лаконічну документацію для функцій, класів, API або цілих кодових баз.
  - **Промпт виклику:** "Ви — технічний письменник. Сгенеруйте markdown документацію для API endpoints, визначених у надане коді. Включіть приклади запитів/відповідей та поясніть кожен параметр."

- **Агент-оптимізатор: Партнер з рефакторингу**

  - **Мета:** Пропонує оптимізації продуктивності та рефакторинг коду для покращення читаності, підтримуваності та ефективності.
  - **Промпт виклику:** "Проаналізуйте надане код на предмет вузьких місць продуктивності або областей, які можна рефакторути для ясності. Запропонуйте конкретні зміни з поясненнями, чому вони є покращенням."

- **Агент-рецензент: Надзирач коду**
  - **Критика:** Агент виконує первинний прохід, виявляючи потенційні помилки, порушення стилю та логічні недоліки, як інструмент статичного аналізу.
  - **Рефлексія:** Агент потім аналізує свою власну критику. Він синтезує висновки, приоритизує найбільш критичні проблеми, відхиляє педантичні або низькоефективні пропозиції та надає високорівневе, дієве резюме для людини-розробника.
  - **Промпт виклику:** "Ви — головний інженер, який проводить огляд коду. По-перше, виконайте детальну критику змін. По-друге, поміркуйте над своєю критикою, щоб надати стислене, приоритизоване резюме найбільш важливої зворотної інформації."

Зрештою, ця модель під керуванням людини створює потужну синергію між стратегічним напрямком розробника та тактичним виконанням агентів. В результаті розробники можуть перевершити рутинні завдання, сконцентрувавши свою експертизу на творчих та архітектурних проблемах, які приносять найбільшу цінність.

## Практична реалізація

### Чек-лист установки

Для ефективної реалізації фреймворку команди людина-агент рекомендується наступне налаштування, зосереджене на збереженні контролю при покращенні ефективності.

1. **Забезпечити доступ до крайніх моделей** Отримати API ключі для щонайменше двох провідних великих мовних моделей, таких як Gemini 2.5 Pro та Claude 4 Opus. Цей двопровідерський підхід дозволяє проводити порівняльний аналіз та захищає від обмежень або простоїв однієї платформи. Ці облікові дані повинні керуватися безпечно, як і будь-який інший виробничий секрет.

2. **Реалізувати локальний оркестратор контексту** Замість спеціальних скриптів використовуйте легкий CLI інструмент або локальний рушій агентів для керування контекстом. Ці інструменти повинні дозволяти вам визначити простий файл конфігурації (наприклад, context.toml) в корені вашого проекту, який указує, які файли, директорії або навіть URL компілювати в єдиний корисний навантаження для промпту LLM. Це забезпечує збереження повного, прозорого контролю над тим, що модель бачить при кожному запиті.

3. **Встановити версіонирану бібліотеку промптів** Створіть виділену директорію /prompts у Git репозиторії вашого проекту. У ній зберігайте промпти виклику для кожного спеціалізованого агента (наприклад, reviewer.md, documenter.md, tester.md) як markdown файли. Ставлення до ваших промптів як до коду дозволяє всій команді співпрацювати, покращувати та версионувати інструкції, дані вашим AI агентам з часом.

4. **Інтегрувати рабочі процеси агентів з Git hooks** Автоматизуйте ваш ритм огляду, використовуючи локальні Git hooks. Наприклад, pre-commit hook може бути налаштований для автоматичного запуску Агента-рецензента на ваших staged змінах. Резюме критики та рефлексії агента може бути представлено прямо у вашому терміналі, надаючи невідкладну зворотну інформацію перед завершенням коммітит та вбудовуючи крок забезпечення якості прямо в ваш процес розробки.

![][image1]

_Рис. 1: Приклади спеціалістів програмування_

### Принципи руководства дополненною командою

Успішне керування цим фреймворком вимагає еволюції від єдиної людини до лідера команди людина-AI, керуючись наступними принципами:

- **Підтримувати архітектурне володіння** Ваша роль полягає в встановленні стратегічного напрямку та володінню високорівневою архітектурою. Ви визначаєте "що" та "чому", використовуючи команду агентів для прискорення "як". Ви є остаточним арбітром дизайну, забезпечуючи відповідність кожного компонента довгостроковому баченню та стандартам якості проекту.

- **Оволодіти мистецтвом брифінгу** Якість виходу агента є прямим відображенням якості його входу. Оволодійте мистецтвом брифінгу, надаючи чіткий, однозначний та комплексний контекст для кожного завдання. Думайте про ваш промпт не як про просту команду, а як про повний пакет брифінгу для нового, високо здатного члена команди.

- **Діяти як остаточний контроль якості** Вихід агента завжди є пропозицією, ніколи командою. Ставайте до зворотної інформації Агента-рецензента як до потужного сигналу, але ви є остаточним контролем якості. Застосуйте вашу тематичну експертизу та специфічні для проекту знання для валідації, оскільки все і схвалення всіх змін, діючи як остаточний страж цілісності кодової бази.

- **Участь у ітеративному діалозі** Найкращі результати виникають з розмови, а не монологу. Якщо первинний вихід агента недосконалий, не відкидайте його — покращуйте його. Надайте коригуючу зворотну інформацію, додайте уточнюючий контекст та запросіть іншу спробу. Цей ітеративний діалог критично важливий, особливо з Агентом-рецензентом, чий вихід "Рефлексія" призначений для початку спільного обговорення, а не просто кінцевого звіту.

## Висновок

Майбутнє розробки коду настало, і воно доповнено. Епоха самотнього програміста поступилася місцем новій парадигмі, де розробники керують командами спеціалізованих AI агентів. Ця модель не зменшує людську роль; вона її піднімає, автоматизуючи рутинні завдання, масштабуючи індивідуальний вплив та досягаючи швидкості розробки, раніше неможливої.

Перекладаючи тактичне виконання на агентів, розробники тепер можуть присвятити свою когнітивну енергію тому, що дійсно важливо: стратегічним інноваціям, стійкому архітектурному дизайну та творчому вирішенню проблем, необхідному для створення продуктів, які радують користувачів. Фундаментальні стосунки були переозначені; це більше не змаганння людини проти машини, а партнерство між людською винахідливістю та AI, працюючи як єдина, бездоганно інтегрована команда.

## Посилання

1. [AI відповідає за генерування понад 30% коду в Google](https://www.reddit.com/r/singularity/comments/1k7rxo0/ai_is_now_writing_well_over_30_of_the_code_at/)
2. [AI відповідає за генерування понад 30% коду в Microsoft](https://www.businesstoday.in/tech-today/news/story/30-of-microsofts-code-is-now-ai-generated-says-ceo-satya-nadella-474167-2025-04-30)

[image1]: ../Assets/appendix-g-image1.png

---

## Навігація

**Назад:** [Додаток F. Під капотом: погляд всередину на механізми міркування агентів](Додаток%20F.%20Під%20капотом%3A%20погляд%20всередину%20на%20механізми%20міркування%20агентів.md)<br>
**Вперед:** [Заключення](../Заключення.md)
