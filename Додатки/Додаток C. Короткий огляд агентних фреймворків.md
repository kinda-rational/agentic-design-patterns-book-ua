# Додаток C - Короткий огляд агентних фреймворків

## LangChain

LangChain — це фреймворк для розробки додатків на основі LLM. Його основна сила полягає в LangChain Expression Language (LCEL), який дозволяє "з'єднувати" компоненти в ланцюжок. Це створює чітку, лінійну послідовність, де вихід одного кроку стає входом для наступного. Він побудований для рабочих процесів, які є спрямованими ациклічними графами (DAG), що означає, що процес протікає в одному напрямку без циклів.

Використовуйте його для:

- **Простий RAG**: Отримати документ, створити промпт, отримати відповідь від LLM.
- **Суммаризація**: Взяти текст користувача, передати його в промпт для суммаризації та повернути результат.
- **Витяг**: Витягти структуровані дані (наприклад, JSON) з блоку тексту.

**Python**

```python
# Простий LCEL ланцюжок концептуально
# (Це не виконуваний код, просто ілюструє потік)
chain = prompt | model | output_parse
```

### LangGraph

LangGraph — це бібліотека, побудована поверх LangChain для обробки більш продвинутих агентних систем. Вона дозволяє визначити ваш рабочий процес як граф з вузлами (функціями або LCEL ланцюжками) та ребрами (умовною логікою). Її основна перевага — здатність створювати цикли, дозволяючи додатку зациклюватися, повторювати спроби або викликати інструменти в гнучкому порядку до завершення завдання. Вона явно управляє станом додатку, який передається між вузлами та оновлюється впродовж процесу.

Використовуйте його для:

- **Мульти-агентні системи**: Агент-керівник направляє завдання спеціалізованим робочим агентам, потенційно зациклюючись до досягнення мети.
- **Агенти планування та виконання**: Агент створює план, виконує крок, а потім повертається до оновлення плану на основі результату.
- **Людина у контурі**: Граф може чекати введення людини перед вирішенням, до якого вузла перейти далі.

| Функція                | LangChain                                 | LangGraph                                 |
| ---------------------- | ----------------------------------------- | ----------------------------------------- |
| Основна абстракція    | Ланцюжок (використовуючи LCEL)                  | Граф вузлів                                |
| Тип рабочого процесу  | Лінійний (спрямований ациклічний граф) | Циклічний (графи з циклами)             |
| Управління станом  | Звичайно без стану на запуск            | Явний та постійний об'єкт стану       |
| Основне використання | Прості, передбачувальні послідовності | Складні, динамічні, станоутворювальні агенти |

### Який вибрати?

- **Виберіть LangChain**, коли ваш додаток має чітку, передбачувальну та лінійну послідовність кроків. Якщо ви можете визначити процес від A до B до C без потреби в циклюванні, LangChain з LCEL — ідеальний інструмент.

- **Виберіть LangGraph**, коли вам потрібно, щоб ваш додаток міркував, планував або працював у циклі. Якщо ваш агент повинен використовувати інструменти, розмірковувати над результатами та потенційно пробувати знову з іншим підходом, вам потрібна циклічна та станоутворювальна природа LangGraph.

**Python**

```python
# Стан графу
class State(TypedDict):
    topic: str
    joke: str
    story: str
    poem: str
    combined_output: str

# Вузли
def call_llm_1(state: State):
    """Перший виклик LLM для генерування початкової жарти"""

    msg = llm.invoke(f"Write a joke about {state['topic']}")
    return {"joke": msg.content}

def call_llm_2(state: State):
    """Другий виклик LLM для генерування історії"""

    msg = llm.invoke(f"Write a story about {state['topic']}")
    return {"story": msg.content}

def call_llm_3(state: State):
    """Третій виклик LLM для генерування вірша"""

    msg = llm.invoke(f"Write a poem about {state['topic']}")
    return {"poem": msg.content}

def aggregator(state: State):
    """Об'єднати жарту та історію в єдиний вихід"""

    combined = f"Here's a story, joke, and poem about {state['topic']}!\n\n"
    combined += f"STORY:\n{state['story']}\n\n"
    combined += f"JOKE:\n{state['joke']}\n\n"
    combined += f"POEM:\n{state['poem']}"
    return {"combined_output": combined}

# Побудувати рабочий процес
parallel_builder = StateGraph(State)

# Додати вузли
parallel_builder.add_node("call_llm_1", call_llm_1)
parallel_builder.add_node("call_llm_2", call_llm_2)
parallel_builder.add_node("call_llm_3", call_llm_3)
parallel_builder.add_node("aggregator", aggregator)

# Додати ребра для з'єднання вузлів
parallel_builder.add_edge(START, "call_llm_1")
parallel_builder.add_edge(START, "call_llm_2")
parallel_builder.add_edge(START, "call_llm_3")
parallel_builder.add_edge("call_llm_1", "aggregator")
parallel_builder.add_edge("call_llm_2", "aggregator")
parallel_builder.add_edge("call_llm_3", "aggregator")
parallel_builder.add_edge("aggregator", END)
parallel_workflow = parallel_builder.compile()

# Показати рабочий процес
display(Image(parallel_workflow.get_graph().draw_mermaid_png()))

# Викликати
state = parallel_workflow.invoke({"topic": "cats"})
print(state["combined_output"])
```

Цей код визначає та запускає рабочий процес LangGraph, який працює паралельно. Його основна мета — одночасно генерувати жарту, історію та вірш на задану тему, а потім об'єднувати їх в єдиний форматований текстовий вихід.

## Google's ADK

Google's Agent Development Kit, або ADK, надає високорівневий, структурований фреймворк для створення та розгортання додатків, що складаються з багатьох взаємодіючих AI агентів. Він контрастує з LangChain та LangGraph, пропонуючи більш упереджену та орієнтовану на виробництво підхід до оркестрування співпраці агентів, а не надання фундаментальних блоків для внутрішньої логіки агента.

LangChain працює на найбільш фундаментальному рівні, пропонуючи компоненти та стандартизовані інтерфейси для створення послідовностей операцій, таких як виклик моделі та розбір її виходу. LangGraph розширює це, вводячи більш гнучкий та потужний контроль потоку; він розглядає рабочий процес агента як граф зі станом. Використовуючи LangGraph, розробник явно визначає вузли, які є функціями або інструментами, та ребра, які диктують шлях виконання. Ця структура графу дозволяє складне, циклічне міркування, де система може зациклюватися, повторювати завдання та приймати рішення на основі явно керованого об'єкта стану, який передається між вузлами. Це дає розробнику детальний контроль над мисленням процесом одного агента або можливість побудувати мульти-агентну систему з нуля.

**Google's ADK абстрагує більшість цієї низькорівневої конструкції графу. Замість того щоб просити розробника визначити кожний вузол та ребро, він надає попередньо побудовані архітектурні паттерни для мульти-агентної взаємодії. Наприклад, ADK має вбудовані типи агентів, такі як `SequentialAgent` або `ParallelAgent`, які автоматично керують потоком контролю між різними агентами. Він архітектирований навколо концепції "команди" агентів, часто з первинним агентом, що делегує завдання спеціалізованим під-агентам. Управління станом та сесією обробляється більш неявно фреймворком, надаючи більш згуртовану, але менш детальну підхід, ніж явна передача стану LangGraph. Тому, хоча LangGraph дає вам детальні інструменти для проектування складної проводки одного робота або команди, Google's ADK дає вам заводську збірну лінію, призначену для створення та управління флотом роботів, які вже знають, як працювати разом.**

**Python**

```python
from google.adk.agents import LlmAgent
from google.adk.tools import google_Search

dice_agent = LlmAgent(
    model="gemini-2.0-flash-exp",
    name="question_answer_agent",
    description="A helpful assistant agent that can answer questions.",
    instruction="""Respond to the query using google search""",
    tools=[google_search],
)
```

Цей код створює **агента з посиленням пошуком**. Коли цей агент отримує питання, він не буде просто покладатися на свої попередні знання. Замість цього, слідуючи своїм інструкціям, він буде використовувати інструмент Google Search для пошуку релевантної, актуальної інформації з інтернету, а потім використовувати цю інформацію для побудови своєї відповіді.

## Crew.AI

CrewAI пропонує фреймворк оркестрування для побудови мульти-агентних систем, фокусуючись на спільних ролях та структурованих процесах. Він працює на більш високому рівні абстракції, ніж фундаментальні набори інструментів, надаючи концептуальну модель, яка відображає людську команду. Замість визначення детального потоку логіки як графу, розробник визначає акторів та їхні призначення, а CrewAI керує їхною взаємодією.

Основними компонентами цього фреймворку є Агенти, Завдання та Команда. Агент визначається не тільки своєю функцією, але й персоною, включаючи конкретну роль, ціль та передісторію, яка направляє його поведінку та стиль спілкування. Завдання — це дискретна одиниця роботи з чіткою описом та очікуваним виходом, призначена конкретному Агенту. Команда — це згуртована одиниця, яка містить Агентів та список Завдань, і вона виконує попередньо визначений Процес. Цей процес диктує рабочий процес, який зазвичай є або послідовним, де вихід одного завдання стає входом для наступного в черзі, або ієрархічним, де агент-менеджер делегує завдання та координує рабочий процес серед інших агентів.

При порівнянні з іншими фреймворками, CrewAI займає відмінну позицію. Він відходить від низькорівневого, явного управління станом та контролю потоку LangGraph, де розробник з'єднує кожний вузол та умовне ребро. Замість побудови скінченного автомата, розробник проектує чартер команди. Хоча Google's ADK надає комплексну, орієнтовану на виробництво платформу для всього життєвого циклу агента, CrewAI концентрується конкретно на логіці співпраці агентів та для симуляції команди фахівців.

**Python**

```python
@crew
def crew(self) -> Crew:
    """Creates the research crew"""
    return Crew(
        agents=self.agents,
        tasks=self.tasks,
        process=Process.sequential,
        verbose=True,
    )
```

Цей код налаштовує послідовний рабочий процес для команди AI агентів, де вони вирішують список завдань у визначеному порядку, з включеним детальним логуванням для моніторингу їхнього прогресу.

## Інші фреймворки розробки агентів

**Microsoft AutoGen**: AutoGen — це фреймворк, зосереджений на оркеструванні декількох агентів, які вирішують завдання через розмову. Його архітектура дозволяє агентам з різними можливостями взаємодіяти, дозволяючи складну декомпозицію проблем та спільне розв'язання. Основна перевага AutoGen — його гнучкий, розмовно-орієнтований підхід, який підтримує динамічну та складну мульти-агентну взаємодію. Однак ця розмовна парадигма може привести до менш передбачуваних шляхів виконання та може потребувати складного промпт-інжинірингу для забезпечення ефективної збіжності завдання.

**LlamaIndex**: LlamaIndex — це фундаментально фреймворк даних, призначений для з'єднання великих мовних моделей з зовнішніми та приватними джерелами даних. Він виділяється в створенні складних конвеєрів приймання та витягу даних, які необхідні для побудови осведомлених агентів, які можуть виконувати RAG. Хоча його можливості індексування та запиту даних винятково потужні для створення контекстно-обізнаних агентів, його рідні інструменти для складного керування потоком агентів та мульти-агентної оркестрування менш розвинені в порівнянні з фреймворками, орієнтованими на агентів. LlamaIndex є оптимальним, коли основне технічне завдання — витяг та синтез даних.

**Haystack**: Haystack — це відкритий фреймворк, призначений для побудови масштабованих та готових до виробництва пошукових систем, які працюють на мовних моделях. Його архітектура складається з модульних, взаємозамінних вузлів, які формують конвеєри для витягу документів, відповідей на запитання та суммаризації. Основна сила Haystack — його фокус на продуктивності та масштабованості для великомасштабних завдань витягу інформації, що робить його придатним для корпоративних додатків. Потенційний компромис полягає в тому, що його дизайн, оптимізований для конвеєрів пошуку, може бути більш жорстким для реалізації високодинамічної та творчої поведінки агентів.

**MetaGPT**: MetaGPT реалізує мульти-агентну систему, присвоюючи ролі та завдання на основі попередньо визначеного набору стандартних операційних процедур (SOP). Цей фреймворк структурує співпрацю агентів, щоб імітувати компанію розробки програмного забезпечення, з агентами, які приймають ролі, такі як менеджери продуктів або інженери для виконання складних завдань. Цей підхід, керований SOP, приводить до висока структурованих та зв'язних виходів, що є значною перевагою для спеціалізованих доменів, таких як генерування коду. Основне обмеження фреймворку — його висока ступінь спеціалізації, що робить його менш адаптованим для загальних агентних завдань поза його основним дизайном.

**SuperAGI**: SuperAGI — це відкритий фреймворк, призначений для надання повної системи управління життєвим циклом для автономних агентів. Він включає функції для забезпечення агентів, моніторингу та графічного інтерфейсу, прагнучи підвищити надійність виконання агентів. Ключова перевага — його фокус на готовності до виробництва, з вбудованими механізмами для обробки загальних режимів відмови, таких як циклювання, та для надання спостережливості продуктивності агентів. Потенційний недолік полягає в тому, що його комплексний платформенний підхід може ввести більше складності та накладних витрат, ніж легший, бібліотечний фреймворк.

**Semantic Kernel**: Розроблений Microsoft, Semantic Kernel — це SDK, який інтегрує великі мовні моделі з звичайним програмним кодом через систему "плагінів" та "планувальників". Він дозволяє LLM викликати нативні функції та оркеструвати рабочі процеси, ефективно обробляючи модель як рушій міркування в більшому програмному додатку. Його основна сила — бездоганна інтеграція з існуючими корпоративними кодовими базами, особливо в середовищах .NET та Python. Концептуальні накладні витрати його архітектури плагінів та планувальників можуть представити більш крутіший крок навчання в порівнянні з простішими фреймворками агентів.

**Strands Agents**: Легкий та гнучкий SDK від AWS, який використовує підхід, керований моделлю, для побудови та запуску AI агентів. Він спроектований бути простим та масштабованим, підтримуючи все від базових розмовних асистентів до складних мульти-агентних автономних систем. Фреймворк не залежить від моделі, пропонуючи широку підтримку різних провайдерів LLM, та включає рідну інтеграцію з MCP для легкого доступу до зовнішніх інструментів. Його основна перевага — простота та гнучкість, з налаштовуваним циклом агента, який легко почати використовувати. Потенційний компромис полягає в тому, що його легкий дизайн означає, що розробникам може потребуватися побудувати більше навколишної операційної інфраструктури, такої як продвинутий моніторинг або системи управління життєвим циклом, які більш комплексні фреймворки можуть надати з коробки.

## Висновок

Ландшафт фреймворків агентів пропонує різноманітний спектр інструментів, від низькорівневих бібліотек для визначення логіки агентів до високорівневих платформ для оркестрування мульти-агентної співпраці. На фундаментальному рівні LangChain дозволяє прості, лінійні рабочі процеси, хоча LangGraph вводить станопевні, циклічні графи для більш складного міркування. Високорівневі фреймворки, такі як CrewAI та Google's ADK, переміщують фокус на оркестрування команд агентів з попередньо визначеними ролями, тоді як інші, такі як LlamaIndex, спеціалізуються на додатках, інтенсивних за даними. Ця різноманітність представляє розробникам основний компромис між детальним контролем систем на основі графів та спрощеною розробкою більш упереджених платформ. Отже, вибір правильного фреймворку залежить від того, чи потребує додаток просту послідовність, динамічний цикл міркування або керовану команду спеціалістів. Зрештою, цей розвиваючийся екосистем дозволяє розробникам будувати все більш складні AI системи, вибираючи точний рівень абстракції, який потребує їхній проект.

## Посилання

1. [LangChain](https://www.langchain.com/)
2. [LangGraph](https://www.langchain.com/langgraph)
3. [Google's ADK](https://google.github.io/adk-docs/)
4. [Crew.AI](https://docs.crewai.com/en/introduction)

---

## Навігація

**Назад:** [Додаток B. Агентні взаємодії ШІ від графічного інтерфейсу до реального світу](Додаток%20B.%20Агентні%20взаємодії%20ШІ%20від%20графічного%20інтерфейсу%20до%20реального%20світу.md)
**Вперед:** [Додаток D. Створення агента з AgentSpace](Додаток%20D.%20Створення%20агента%20з%20AgentSpace.md)
