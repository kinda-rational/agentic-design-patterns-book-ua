# Розділ 20: Пріоритизація

У складних, динамічних середовищах агенти часто зустрічаються з численними потенційними діями, конфліктуючими цілями та обмеженими ресурсами. Без визначеного процесу для визначення наступної дії агенти можуть відчувати зниження ефективності, операційні затримки або неспроможність досягти ключових цілей. Шаблон пріоритизації вирішує цю проблему, дозволяючи агентам оцінювати та ранжирувати завдання, цілі або дії на основі їхної значимості, терміновості, залежностей та встановлених критеріїв. Це забезпечує концентрацію зусиль агентів на найбільш критичних завданнях, що приводить до підвищення ефективності та узгодженості з цілями.

## Огляд шаблону пріоритизації

Агенти використовують пріоритизацію для ефективного управління завданнями, цілями та підцілями, визначаючи наступні дії. Цей процес сприяє прийняттю обґрунтованих рішень при роботі з численними вимогами, надаючи пріоритет життєво важливим або терміновим діям над менш критичними. Він особливо актуальний у реальних сценаріях, де ресурси обмежені, час лімітований, а цілі можуть конфліктувати.

Фундаментальні аспекти пріоритизації агентів зазвичай включають кілька елементів. По-перше, визначення критеріїв встановлює правила або метрики для оцінки завдань. Вони можуть включати терміновість (часова чутливість завдання), важливість (вплив на основну ціль), залежності (чи є завдання передумовою для інших), доступність ресурсів (готовність необхідних інструментів або інформації), аналіз затрат/вигод (зусилля проти очікуваного результату) та користувальницькі переваги для персоналізованих агентів. По-друге, оцінка завдань включає аналіз кожного потенційного завдання проти цих визначених критеріїв, використовуючи методи від простих правил до складної оцінки або міркування LLM. По-третє, логіка планування або вибору стосується алгоритму, який на основі оцінок обирає оптимальне наступне дію або послідовність завдань, потенційно використовуючи чергу або передовий компонент планування. Нарешті, динамічна репріоритизація дозволяє агенту змінювати пріоритети при зміні обставин, наприклад, при появі нової критичної події або наближенні крайнього терміну, забезпечуючи адаптивність та відзивчивість агента.

Пріоритизація може відбуватися на різних рівнях: вибір загальної мети (пріоритизація цілей високого рівня), упорядковування кроків у межах плану (пріоритизація підзавдань) або вибір наступної безпосередної дії з доступних варіантів (вибір дії). Ефективна пріоритизація дозволяє агентам демонструвати більш інтелектуальну, ефективну та стійку поведінку, особливо у складних, багатоцільових середовищах. Це відображає організацію людських команд, де менеджери пріоритизують завдання, враховуючи внесок усіх учасників.

## Практичні застосування та варіанти використання

У різних реальних додатках AI агенти демонструють складне використання пріоритизації для прийняття своєчасних та ефективних рішень.

- **Автоматизована підтримка клієнтів**: Агенти пріоритизують терміні запити, такі як звіти про збої системи, над рутинними питаннями, такими як скидання паролів. Вони також можуть надавати перевагу клієнтам високої цінності.

- **Хмарні обчислення**: AI керує та планує ресурси, пріоритизуючи розподіл критично важливим додаткам у періоди пікового навантаження, тоді як менш терміні пакетні завдання відкладаються на непікові години для оптимізації витрат.

- **Системи автономного керування**: Постійно пріоритизують дії для забезпечення безпеки та ефективності. Наприклад, гальмування для уникнення зіткнення має пріоритет над дотриманням дисципліни руху або оптимізацією витрати палива.

- **Фінансова торгівля**: Боти пріоритизують угоди, аналізуючи такі фактори, як умови ринку, толерантність до ризику, розмір прибутку та новини в реальному часі, забезпечуючи швидке виконання високопріоритетних транзакцій.

- **Управління проектами**: AI агенти пріоритизують завдання на проектній дошці на основі крайніх термінів, залежностей, доступності команди та стратегічної важливості.

- **Кібербезпека**: Агенти, які мають моніторити мережевий трафік, пріоритизують попередження, оцінюючи серйозність загрози, потенційний вплив та критичність активів, забезпечуючи негайну реакцію на найнебезпечніші загрози.

- **Персональні AI помічники**: Використовують пріоритизацію для управління повсякденним життям, організуючи события календаря, нагадування та сповіщення відповідно до визначеної користувачем важливості, наближених крайніх термінів та поточного контексту.

Ці приклади в сукупності ілюструють, як здатність до пріоритизації є фундаментальною для вдосконалення продуктивності та можливостей прийняття рішень AI агентів у широкому спектрі ситуацій.

## Практичний приклад коду

Наступний приклад демонструє розробку AI агента-менеджера проектів з використанням LangChain. Цей агент полегшує створення, пріоритизацію та призначення завдань членам команди, ілюструючи застосування великих мовних моделей з користувальницькими інструментами для автоматизованого управління проектами.

```python
import os
import asyncio
from typing import List, Optional, Dict, Type

from dotenv import load_dotenv
from pydantic import BaseModel, Field

from langchain_core.prompts import ChatPromptTemplate
from langchain_core.tools import Tool
from langchain_openai import ChatOpenAI
from langchain.agents import AgentExecutor, create_react_agent
from langchain.memory import ConversationBufferMemory

# --- 0. Конфігурація та налаштування ---
# Завантажує OPENAI_API_KEY з файлу .env.
load_dotenv()

# Клієнт ChatOpenAI автоматично підхоплює ключ API з оточення.
llm = ChatOpenAI(temperature=0.5, model="gpt-4o-mini")

# --- 1. Система управління завданнями ---

class Task(BaseModel):
    """Представляє одне завдання в системі."""
    id: str
    description: str
    priority: Optional[str] = None  # P0, P1, P2
    assigned_to: Optional[str] = None  # Ім'я працівника

class SuperSimpleTaskManager:
    """Ефективний та надійний менеджер завдань в пам'яті."""
    def __init__(self):
        # Використовуйте словник для O(1) пошуків, оновлень та видалень.
        self.tasks: Dict[str, Task] = {}
        self.next_task_id = 1

    def create_task(self, description: str) -> Task:
        """Створює та зберігає нове завдання."""
        task_id = f"TASK-{self.next_task_id:03d}"
        new_task = Task(id=task_id, description=description)
        self.tasks[task_id] = new_task
        self.next_task_id += 1
        print(f"DEBUG: Завдання створено - {task_id}: {description}")
        return new_task

    def update_task(self, task_id: str, **kwargs) -> Optional[Task]:
        """Безпечно оновлює завдання за допомогою model_copy Pydantic."""
        task = self.tasks.get(task_id)
        if task:
            # Використовуйте model_copy для типобезпечних оновлень.
            update_data = {k: v for k, v in kwargs.items() if v is not None}
            updated_task = task.model_copy(update=update_data)
            self.tasks[task_id] = updated_task
            print(f"DEBUG: Завдання {task_id} оновлено з {update_data}")
            return updated_task

        print(f"DEBUG: Завдання {task_id} не знайдено для оновлення.")
        return None

    def list_all_tasks(self) -> str:
        """Перелічує всі завдання, які наразі в системі."""
        if not self.tasks:
            return "Завдань у системі немає."

        task_strings = []
        for task in self.tasks.values():
            task_strings.append(
                f"ID: {task.id}, Опис: '{task.description}', "
                f"Пріоритет: {task.priority or 'N/A'}, "
                f"Призначено: {task.assigned_to or 'N/A'}"
            )
        return "Поточні завдання:\n" + "\n".join(task_strings)

task_manager = SuperSimpleTaskManager()

# --- 2. Інструменти для агента менеджера проектів ---

# Використовуйте моделі Pydantic для аргументів інструментів для кращої валідації та ясності.
class CreateTaskArgs(BaseModel):
    description: str = Field(description="Детальний опис завдання.")

class PriorityArgs(BaseModel):
    task_id: str = Field(description="ID завдання для оновлення, наприклад 'TASK-001'.")
    priority: str = Field(description="Пріоритет для встановлення. Повинен бути одним з: 'P0', 'P1', 'P2'.")

class AssignWorkerArgs(BaseModel):
    task_id: str = Field(description="ID завдання для оновлення, наприклад 'TASK-001'.")
    worker_name: str = Field(description="Ім'я працівника для призначення завдання.")

def create_new_task_tool(description: str) -> str:
    """Створює нове завдання проекту з заданим описом."""
    task = task_manager.create_task(description)
    return f"Створено завдання {task.id}: '{task.description}'."

def assign_priority_to_task_tool(task_id: str, priority: str) -> str:
    """Призначає пріоритет (P0, P1, P2) до заданого ID завдання."""
    if priority not in ["P0", "P1", "P2"]:
        return "Невірний пріоритет. Повинен бути P0, P1 або P2."
    task = task_manager.update_task(task_id, priority=priority)
    return f"Призначено пріоритет {priority} завданню {task.id}." if task else f"Завдання {task_id} не знайдено."

def assign_task_to_worker_tool(task_id: str, worker_name: str) -> str:
    """Призначає завдання конкретному працівнику."""
    task = task_manager.update_task(task_id, assigned_to=worker_name)
    return f"Призначено завдання {task.id} до {worker_name}." if task else f"Завдання {task_id} не знайдено."

# Всі інструменти, які може використовувати PM агент
pm_tools = [
    Tool(
        name="create_new_task",
        func=create_new_task_tool,
        description="Використовуйте це першим, щоб створити нове завдання та отримати його ID.",
        args_schema=CreateTaskArgs
    ),
    Tool(
        name="assign_priority_to_task",
        func=assign_priority_to_task_tool,
        description="Використовуйте це для призначення пріоритету завданню після його створення.",
        args_schema=PriorityArgs
    ),
    Tool(
        name="assign_task_to_worker",
        func=assign_task_to_worker_tool,
        description="Використовуйте це для призначення завдання конкретному працівнику після його створення.",
        args_schema=AssignWorkerArgs
    ),
    Tool(
        name="list_all_tasks",
        func=task_manager.list_all_tasks,
        description="Використовуйте це для перелічування всіх поточних завдань та їхнього статусу."
    ),
]

# --- 3. Визначення агента менеджера проектів ---

pm_prompt_template = ChatPromptTemplate.from_messages([
    ("system", """Ви зосереджений агент менеджера проектів LLM. Ваша мета - ефективно керувати завданнями проекту.

    Коли ви отримаєте новий запит на завдання, дотримуйтеся цих кроків:
    1.  Спочатку створіть завдання з заданим описом за допомогою інструменту `create_new_task`. Ви повинні зробити це першим, щоб отримати `task_id`.
    2.  Далі проаналізуйте запит користувача, щоб побачити, чи згадується пріоритет або призначений.
        - Якщо згадується пріоритет (наприклад, "терміново", "ASAP", "критично"), зберіть його до P0. Використовуйте `assign_priority_to_task`.
        - Якщо згадується робітник, використовуйте `assign_task_to_worker`.
    3.  Якщо якась інформація (пріоритет, призначений) відсутня, ви повинні зробити розумне стандартне призначення (наприклад, призначити пріоритет P1 та призначити до 'Worker A').
    4.  Після повної обробки завдання використовуйте `list_all_tasks` для відображення кінцевого стану.

    Доступні робітники: 'Worker A', 'Worker B', 'Review Team'
    Рівні пріоритету: P0 (найвище), P1 (середнє), P2 (найнижче)
    """),
    ("placeholder", "{chat_history}"),
    ("human", "{input}"),
    ("placeholder", "{agent_scratchpad}")
])

# Створіть виконавця агента
pm_agent = create_react_agent(llm, pm_tools, pm_prompt_template)
pm_agent_executor = AgentExecutor(
    agent=pm_agent,
    tools=pm_tools,
    verbose=True,
    handle_parsing_errors=True,
    memory=ConversationBufferMemory(memory_key="chat_history", return_messages=True)
)

# --- 4. Простий цикл взаємодії ---

async def run_simulation():
    print("--- Симуляція менеджера проектів ---")

    # Сценарій 1: Обробка нового, терміного запиту на функцію
    print("\n[Запит користувача] Мені потрібна нова система входу, реалізована ASAP. Вона повинна бути призначена Worker B.")
    await pm_agent_executor.ainvoke({"input": "Створіть завдання для реалізації нової системи входу. Це терміново та повинно бути призначено Worker B."})

    print("\n" + "-"*60 + "\n")

    # Сценарій 2: Обробка менш терміного оновлення контенту з меншою кількістю деталей
    print("[Запит користувача] Нам потрібно переглянути вміст маркетингового вебсайту.")
    await pm_agent_executor.ainvoke({"input": "Керуйте новим завданням: Переглянути вміст маркетингового вебсайту."})

    print("\n--- Симуляція завершена ---")

# Запустіть симуляцію
if __name__ == "__main__":
    asyncio.run(run_simulation())
```

Цей код реалізує просту систему управління завданнями з використанням Python та LangChain, призначену для симуляції агента-менеджера проектів, що працює на основі великої мовної моделі.

Система використовує клас `SuperSimpleTaskManager` для ефективного управління завданнями в пам'яті, застосовуючи структуру словника для швидкого отримання даних. Кожне завдання представлено моделлю Pydantic `Task`, яка включає такі атрибути, як унікальний ідентифікатор, описовий текст, необов'язковий рівень пріоритету (P0, P1, P2) та необов'язкове призначення працівника. Використання пам'яті варіюється залежно від типу завдань, кількості робітників та інших факторів. Менеджер завдань надає методи для створення завдань, їхніх модифікацій та отримання всіх завдань.

Агент взаємодіє з менеджером завдань через визначений набір інструментів. Ці інструменти полегшують створення нових завдань, призначення пріоритетів завданням, розподіл завдань персоналу та вивід списку всіх завдань. Кожен інструмент інкапсульований для забезпечення взаємодії з екземпляром `SuperSimpleTaskManager`. Моделі Pydantic використовуються для визначення необхідних аргументів інструментів, забезпечуючи валідацію даних.

`AgentExecutor` налаштовується з мовною моделлю, набором інструментів та компонентом пам'яті розмови для збереження контекстуальної безперервності. Визначено спеціальний `ChatPromptTemplate` для спрямування поведінки агента в його ролі управління проектами. Промпт інструктує агента почати зі створення завдання, потім призначити пріоритет та персонал відповідно до інструкцій, та завершити повним списком завдань. Стандартні призначення, такі як пріоритет P1 та 'Worker A', передбачені у промпті для випадків, коли інформація відсутня.

Код включає асинхронну функцію симуляції (`run_simulation`) для демонстрації операційних можливостей агента. Симуляція виконує два різних сценарії: управління терміним завданням з призначеним персоналом та управління менш терміним завданням з мінімальним введенням. Дії агента та логічні процеси виводяться в консоль завдяки активації `verbose=True` в `AgentExecutor`.

## Короткий огляд

**Що:** AI агенти, що працюють у складних середовищах, стикаються з численними потенційними діями, конфліктуючими цілями та обмеженими ресурсами. Без чіткого методу визначення наступного кроку ці агенти ризикують стати неефективними та непродуктивними. Це може привести до значних операційних затримок або повної неспроможності виконати основні цілі. Основна проблема полягає в управлінні цією величезною кількістю варіантів вибору для забезпечення цілеспрямованої та логічної дії агента.

**Чому:** Шаблон пріоритизації надає стандартизоване рішення цієї проблеми, дозволяючи агентам ранжувати завдання та цілі. Це досягається шляхом встановлення чітких критеріїв, таких як терміновість, важливість, залежності та вартість ресурсів. Агент потім оцінює кожне потенційне дію проти цих критеріїв для визначення найбільш критичного та своєчасного курсу дії. Ця здатність агента дозволяє системі динамічно адаптуватися до змінюваних обставин та ефективно керувати обмеженими ресурсами. Сосередоточившись на елементах найвищого пріоритету, поведінка агента стає більш інтелектуальною, стійкою та узгодженою з його стратегічними цілями.

**Практичне правило:** Використовуйте шаблон пріоритизації, коли агентна система повинна автономно керувати численними, часто конфліктуючими завданнями або цілями в умовах обмежень ресурсів для ефективної роботи в динамічному середовищі.

**Візуальне резюме:**

![][image1]

Рис.1: Шаблон проектування пріоритизації

## Ключові висновки

- Пріоритизація дозволяє AI агентам ефективно функціонувати в складних, багатогранних середовищах.
- Агенти використовують встановлені критерії, такі як терміновість, важливість та залежності, для оцінки та ранжирування завдань.
- Динамічна репріоритизація дозволяє агентам коригувати свій операційний фокус у відповідь на зміни в реальному часі.
- Пріоритизація відбувається на різних рівнях, охоплюючи загальні стратегічні цілі та невідкладні тактичні рішення.
- Ефективна пріоритизація приводить до підвищення ефективності та поліпшення операційної стійкості AI агентів.

## Висновки

Висновуючи, шаблон пріоритизації є наріжним каменем ефективного агентного AI, оснащуючи системи здатністю навігувати в складностях динамічних середовищ з цілеспрямованістю та інтелектом. Це дозволяє агенту автономно оцінювати численні конфліктуючі завдання та цілі, приймаючи обґрунтовані рішення про те, де зосередити свої обмежені ресурси. Ця здатність агента виходить за межи простого виконання завдань, дозволяючи системі діяти як проактивний, стратегічний суб'єкт, що приймає рішення. Зважуючи такі критерії, як терміновість, важливість та залежності, агент демонструє складний, людиноподібний процес міркування.

Ключовою характеристикою цієї поведінки агента є динамічна репріоритизація, яка надає агенту автономію адаптувати свій фокус в реальному часі при зміні умов. Як показано в прикладі коду, агент інтерпретує неоднозначні запити, автономно обирає та використовує відповідні інструменти та логічно упорядковує свої дії для досягнення цілей. Ця здатність до самокерування робочим процесом відрізняє істинну агентну систему від простого автоматизованого скрипту. Вкінцевому рахунку, оволодіння пріоритизацією є основоположним для створення стійких та інтелектуальних агентів, здатних ефективно та надійно працювати в будь-якому складному, реальному сценарії.

## Література

1. Examining the Security of Artificial Intelligence in Project Management: A Case Study of AI-driven Project Scheduling and Resource Allocation in Information Systems Projects; https://www.irejournals.com/paper-details/1706160

2. AI-Driven Decision Support Systems in Agile Software Project Management: Enhancing Risk Mitigation and Resource Allocation; https://www.mdpi.com/2079-8954/13/3/208

[image1]: ../Assets/chapter-20-image1.png

---

## Навігація

**Назад:** [Розділ 19. Оцінка та моніторинг](Розділ%2019.%20Оцінка%20та%20моніторинг.md)<br>
**Вперед:** [Розділ 21. Дослідження та відкриття](Розділ%2021.%20Дослідження%20та%20відкриття.md)
