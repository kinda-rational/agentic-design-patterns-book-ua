# Розділ 15: Міжагентна комунікація (A2A)

Окремі AI агенти часто стикаються з обмеженнями при вирішенні складних багатогранних проблем, навіть володіючи передовими можливостями. Для подолання цього міжагентна комунікація (A2A) дозволяє різним AI агентам, потенційно розробленим з використанням різних фреймворків, ефективно співпрацювати. Ця співпраця включає безшовну координацію, делегування задач та обмін інформацією.

Протокол A2A від Google являє собою відкритий стандарт, призначений для забезпечення такої універсальної взаємодії. У цьому розділі ми розглянемо A2A, його практичне застосування та реалізацію в рамках Google ADK.

# Огляд паттерну міжагентної комунікації

Протокол Agent2Agent (A2A) являє собою відкритий стандарт, призначений для забезпечення взаємодії та співпраці між різними фреймворками AI агентів. Він забезпечує сумісність, дозволяючи AI агентам, розробленим з використанням таких технологій, як LangGraph, CrewAI або Google ADK, працювати разом незалежно від їхнього походження або відмінностей у фреймворках.

A2A підтримується рядом технологічних компаній та постачальників послуг, включаючи Atlassian, Box, LangChain, MongoDB, Salesforce, SAP і ServiceNow. Microsoft планує інтегрувати A2A в Azure AI Foundry та Copilot Studio, демонструючи свою прихильність відкритим протоколам. Крім того, Auth0 та SAP інтегрують підтримку A2A у свої платформи та агентів.

Як протокол з відкритим кодом, A2A приймає внесок спільноти для сприяння його розвитку та широкому впровадженню.

## Основні концепції A2A

Протокол A2A надає структурований підхід до взаємодії агентів, заснований на кількох ключових концепціях. Ретельне розуміння цих концепцій має вирішальне значення для всіх, хто розробляє або інтегрується з A2A-сумісними системами. Основними стовпами A2A є основні учасники, Agent Card, виявлення агентів, комунікація та задачі, механізми взаємодії та безпека, які будуть детально розглянуті.

**Основні учасники:** A2A включає три основні сутності:

- User: ініціює запити на допомогу агента.
- A2A Client (агент-клієнт): додаток або AI агент, який діє від імені користувача для запиту дій або інформації.
- A2A Server (віддалений агент): AI агент або система, яка надає HTTP endpoint для обробки запитів клієнтів та повернення результатів. Віддалений агент працює як "непрозора" система, що означає, що клієнту не потрібно розуміти деталі його внутрішньої роботи.

**Agent Card:** Цифрова ідентичність агента визначається його Agent Card, як правило JSON-файлом. Цей файл містить ключову інформацію для взаємодії з клієнтом та автоматичного виявлення, включаючи ідентичність агента, URL endpoint та версію. Він також деталізує підтримувані можливості, такі як потокова передача або push-сповіщення, специфічні навички, режими введення/виведення за умовчанням та вимоги аутентифікації. Нижче наведено приклад Agent Card для WeatherBot.

```json
{
  "name": "WeatherBot",
  "description": "Надає точні прогнози погоди та історичні дані.",
  "url": "http://weather-service.example.com/a2a",
  "version": "1.0.0",
  "capabilities": {
    "streaming": true,
    "pushNotifications": false,
    "stateTransitionHistory": true
  },
  "authentication": {
    "schemes": ["apiKey"]
  },
  "defaultInputModes": ["text"],
  "defaultOutputModes": ["text"],
  "skills": [
    {
      "id": "get_current_weather",
      "name": "Get Current Weather",
      "description": "Отримайте météо в режимі реального часу для будь-якого місця.",
      "inputModes": ["text"],
      "outputModes": ["text"],
      "examples": [
        "Яка погода в Парижі?",
        "Поточні умови в Токіо"
      ],
      "tags": ["weather", "current", "real-time"]
    },
    {
      "id": "get_forecast",
      "name": "Get Forecast",
      "description": "Отримайте прогноз погоди на 5 днів.",
      "inputModes": ["text"],
      "outputModes": ["text"],
      "examples": [
        "Прогноз на 5 днів для Нью-Йорка",
        "Піде дощ у Лондоні цих вихідних?"
      ],
      "tags": ["weather", "forecast", "prediction"]
    }
  ]
}
```

**Виявлення агентів:** дозволяє клієнтам знаходити Agent Cards, які описують можливості доступних A2A серверів. Для цього процесу існує кілька стратегій:

- **Well-Known URI:** Агенти розміщують свою Agent Card за стандартизованою Path (наприклад, /.well-known/agent.json). Цей підхід забезпечує широку, часто автоматизовану доступність для публічного або доменно-специфічного використання.
- **Куратовані реєстри:** Вони надають централізований каталог, де Agent Cards публікуються та можуть бути запитані на основі конкретних критеріїв. Це добре підходить для корпоративних середовищ, що вимагають централізованого управління та контролю доступу.
- **Пряма конфігурація:** Інформація Agent Card встроюється або передається в приватному порядку. Цей метод підходить для тісно пов'язаних або приватних систем, де динамічне виявлення не є критичним.

Незалежно від обраного методу, важливо забезпечити безпеку endpoints Agent Card. Це може бути досягнуто через контроль доступу, взаємний TLS (mTLS) або мережеві обмеження, особливо якщо карта містить чутливу (хоча й не секретну) інформацію.

**Комунікація та задачі:** У фреймворку A2A комунікація структурована навколо асинхронних задач, які представляють фундаментальні одиниці роботи для довгоживучих процесів. Кожній задачі присвоюється унікальний ідентифікатор, і вона проходить через серію станів — таких як submitted, working або completed — конструкція, яка підтримує паралельну обробку в складних операціях. Комунікація між агентами відбувається через сообщение (Message).

Ця комунікація містить атрибути, які є метаданими ключ-значення, що описують сообщение (наприклад, його пріоритет або час створення), та одну або кілька частин, які несуть фактичний контент, що доставляється, такий як простий текст, файли або структуровані JSON дані. Матеріальні результати, генеровані агентом під час задачі, називаються артефактами. Як і сообщення, артефакти також складаються з однієї або кількох частин і можуть передаватися поступово зі надходженням результатів. Уся комунікація в рамках фреймворку A2A проводиться через HTTP(S) з використанням протоколу JSON-RPC 2.0 для payloads. Для збереження неперервності через безліч взаємодій використовується згенерований сервером contextId для групування пов'язаних задач та збереження контексту.

**Механізми взаємодії:** Request/Response (Polling), Server-Sent Events (SSE). A2A надає безліч методів взаємодії для задоволення різноманітних потреб AI додатків, кожен з власним відмітним механізмом:

- **Синхронний Request/Response:** Для швидких, негайних операцій. У цій моделі клієнт надсилає запит і активно чекає, поки сервер його обробить та повернеться повний відповідь в одному синхронному обміні.
- **Асинхронний Polling:** Підходить для задач, які займають більше часу для обробки. Клієнт надсилає запит, і сервер негайно його підтверджує зі статусом "working" та ID задачі. Клієнт потім вільний виконувати інші дії та може періодично запитувати сервер, надсилаючи нові запити для перевірки статусу задачі, поки вона не буде позначена як "completed" або "failed".
- **Потокові оновлення (Server-Sent Events - SSE):** Ідеально для отримання результатів у реальному часі та пошагових результатів. Цей метод встановлює постійне одностороннє з'єднання від сервера до клієнта. Він дозволяє віддаленому агенту постійно надсилати оновлення, такі як зміни статусу або часткові результати, без необхідності клієнтові робити множинні запити.
- **Push сповіщення (Webhooks):** Призначені для дуже довгоживучих або ресурсоємних задач, де утримання постійного з'єднання або частий polling неефективні. Клієнт може зареєструвати webhook URL, і сервер надішле асинхронне сповіщення ("push") на цей URL, коли статус задачі суттєво змінюється (наприклад, при завершенні).

Agent Card вказує, підтримує ли агент streaming або push notification можливості. Крім того, A2A є модально-агностичним, що означає, що він може полегшити ці паттерни взаємодії не тільки для тексту, але й для інших типів даних, таких як аудіо та відео, забезпечуючи багаті, мультимодальні AI додатки. Як потокові, так і push notification можливості зазначаються в Agent Card.

```json
# Приклад синхронного запиту
{
  "jsonrpc": "2.0",
  "id": "1",
  "method": "sendTask",
  "params": {
    "id": "task-001",
    "sessionId": "session-001",
    "message": {
      "role": "user",
      "parts": [
        {
          "type": "text",
          "text": "Який курс обміну USD на EUR?"
        }
      ]
    },
    "acceptedOutputModes": ["text/plain"],
    "historyLength": 5
  }
}
```

Синхронний запит використовує метод sendTask, де клієнт запитує та очікує одиничної повної відповіді на свій запит. На відміну від цього, потоковий запит використовує метод sendTaskSubscribe для встановлення постійного з'єднання, дозволяючи агенту надсилати назад множинні пошагові оновлення або часткові результати протягом часу.

```json
# Приклад потокового запиту
{
  "jsonrpc": "2.0",
  "id": "2",
  "method": "sendTaskSubscribe",
  "params": {
    "id": "task-002",
    "sessionId": "session-001",
    "message": {
      "role": "user",
      "parts": [
        {
          "type": "text",
          "text": "Який курс JPY до GBP сьогодні?"
        }
      ]
    },
    "acceptedOutputModes": ["text/plain"],
    "historyLength": 5
  }
}
```

**Безпека:** Міжагентна комунікація (A2A) являє собою вітальний компонент архітектури системи, що забезпечує безпечний та безшовний обмін даними між агентами. Вона забезпечує надійність та цілісність через кілька вбудованих механізмів.

Взаємна безпека транспортного рівня (TLS): Встановлюються зашифровані та аутентифіковані з'єднання для запобігання несанкціонованому доступу та перехопленню даних, забезпечуючи безпечну комунікацію.

Комплексні журнали аудиту: Уся міжагентна комунікація ретельно записується, деталізуючи потік інформації, учасників агентів та дії. Цей аудиторський слід має вирішальне значення для підзвітності, усунення неполадок та аналізу безпеки.

Декларація Agent Card: Вимоги аутентифікації явно декларуються в Agent Card, конфігураційному артефакті, що описує ідентичність агента, можливості та політики безпеки. Це централізує та спрощує управління аутентифікацією.

Обробка облікових даних: Агенти зазвичай аутентифікуються, використовуючи безпечні облікові дані, такі як OAuth 2.0 токени або API ключі, передавлені через HTTP заголовки. Цей метод запобігає виставленню облікових даних в URLs або телах сообщений, підвищуючи загальну безпеку.

## A2A vs. MCP

A2A являє собою протокол, який доповнює Model Context Protocol (MCP) від Anthropic (див. Рис. 1). У той час як MCP зосереджується на структуруванні контексту для агентів та їхній взаємодії з зовнішніми даними та інструментами, A2A полегшує координацію та комунікацію між агентами, забезпечуючи делегування задач та співпрацю.

![][image2]

Рис.1: Порівняння протоколів A2A та MCP

Мета A2A — підвищити ефективність, знизити витрати на інтеграцію та сприяти інноваціям та сумісності в розробці складних багатоагентних систем AI. Тому ретельне розуміння основних компонентів A2A та операційних методів є істотним для його ефективного проектування, реалізації та застосування в побудові спільних та сумісних систем агентів AI.

# Практичні застосування та сценарії використання

Міжагентна комунікація є незамінною для побудови складних рішень AI у різних галузях, забезпечуючи модульність, масштабованість та розширений інтелект.

- **Співпраця між фреймворками:** Основний сценарій використання A2A — забезпечення незалежних агентів AI, незалежно від їхніх базових фреймворків (наприклад, ADK, LangChain, CrewAI), для комунікації та співпраці. Це фундаментально для побудови складних багатоагентних систем, де різні агенти спеціалізуються на різних аспектах проблеми.
- **Автоматизована оркестрація робочих процесів:** У корпоративних умовах A2A може полегшити складні робочі процеси, дозволяючи агентам делегувати та координувати задачі. Наприклад, агент може обробляти початковий збір даних, потім делегувати іншому агенту для аналізу, і нарешті третьому для генерування звіту, все спілкуючись через протокол A2A.
- **Динамічне вилучення інформації:** Агенти можуть спілкуватися для вилучення та обміну інформацією в режимі реального часу. Основний агент може запросити живі дані про ринок у спеціалізованого "агента вилучення даних", який потім використовує зовнішні API для збору інформації та її відправки назад.

# Практичний приклад коду

Давайте розглянемо практичне застосування протоколу A2A. Репозиторій за адресою https://github.com/google-a2a/a2a-samples/tree/main/samples надає приклади на Java, Go та Python, які ілюструють, як різні фреймворки агентів, такі як LangGraph, CrewAI, Azure AI Foundry та AG2, можуть спілкуватися, використовуючи A2A. Весь код в цьому репозиторії виданий під ліцензією Apache 2.0. Для подальшої ілюстрації основних концепцій A2A ми розглянемо фрагменти коду, зосередивши увагу на налаштуванні A2A сервера з використанням агента на основі ADK з інструментами, аутентифікованими Google. Розглядаючи https://github.com/google-a2a/a2a-samples/blob/main/samples/python/agents/birthday_planner_adk/calendar_agent/adk_agent.py

```python
import datetime
from google.adk.agents import LlmAgent  # type: ignore[import-untyped]
from google.adk.tools.google_api_tool import CalendarToolset  # type: ignore[import-untyped]


async def create_agent(client_id, client_secret) -> LlmAgent:
    """Конструює ADK агента."""
    toolset = CalendarToolset(client_id=client_id, client_secret=client_secret)
    return LlmAgent(
        model='gemini-2.0-flash-001',
        name='calendar_agent',
        description="Агент, який може допомогти керувати календарем користувача",
        instruction=f"""
Ви агент, який може допомогти керувати календарем користувача.

Користувачі будуть запитувати інформацію про стан їхнього календаря
або робити зміни до свого календаря. Використовуйте надані інструменти для взаємодії з календарем API.

Якщо не зазначено, припустіть, що календар, який користувач хоче, - це 'первинний' календар.

При використанні інструментів Calendar API використовуйте добре сформовані RFC3339 тимчасові мітки.

Сьогодні {datetime.datetime.now()}.
""",
        tools=await toolset.get_tools(),
    )
```

Цей код Python визначає асинхронну функцію `create_agent`, яка конструює ADK LlmAgent. Вона починається з ініціалізації `CalendarToolset`, використовуючи надані облікові дані клієнта для доступу до Google Calendar API. Потім створюється екземпляр `LlmAgent`, налаштований з вказаною моделлю Gemini, описовим ім'ям та інструкціями для керування календарем користувача. Агент оснащений інструментами календаря від `CalendarToolset`, дозволяючи йому взаємодіяти з Calendar API та відповідати на запити користувача щодо станів календаря або модифікацій. Інструкції агента динамічно включають поточну дату для часового контексту. Щоб проілюструвати, як агент конструюється, давайте розглянемо ключовий розділ з calendar_agent, знайдений у прикладах A2A на GitHub.

Код нижче показує, як агент визначається з його специфічними інструкціями та інструментами. Зверніть увагу, що показано тільки код, необхідний для пояснення цієї функціональності; ви можете отримати доступ до повного файлу тут: https://github.com/a2aproject/a2a-samples/blob/main/samples/python/agents/birthday_planner_adk/calendar_agent/__main__.py

```python
def main(host: str, port: int):
    # Перевірте, чи встановлено API ключ.
    # Не потрібно, якщо використовуються API Vertex AI.
    if os.getenv('GOOGLE_GENAI_USE_VERTEXAI') != 'TRUE' and not os.getenv(
        'GOOGLE_API_KEY'
    ):
        raise ValueError(
            'Змінна середовища GOOGLE_API_KEY не встановлена і '
            'GOOGLE_GENAI_USE_VERTEXAI не TRUE.'
        )

    skill = AgentSkill(
        id='check_availability',
        name='Check Availability',
        description="Перевіряє доступність користувача на час, використовуючи його Google Calendar",
        tags=['calendar'],
        examples=['Я вільний з 10:00 до 11:00 завтра?'],
    )

    agent_card = AgentCard(
        name='Calendar Agent',
        description="Агент, який може керувати календарем користувача",
        url=f'http://{host}:{port}/',
        version='1.0.0',
        defaultInputModes=['text'],
        defaultOutputModes=['text'],
        capabilities=AgentCapabilities(streaming=True),
        skills=[skill],
    )

    adk_agent = asyncio.run(create_agent(
        client_id=os.getenv('GOOGLE_CLIENT_ID'),
        client_secret=os.getenv('GOOGLE_CLIENT_SECRET'),
    ))
    runner = Runner(
        app_name=agent_card.name,
        agent=adk_agent,
        artifact_service=InMemoryArtifactService(),
        session_service=InMemorySessionService(),
        memory_service=InMemoryMemoryService(),
    )
    agent_executor = ADKAgentExecutor(runner, agent_card)

    async def handle_auth(request: Request) -> PlainTextResponse:
        await agent_executor.on_auth_callback(
            str(request.query_params.get('state')), str(request.url)
        )
        return PlainTextResponse('Аутентифікація успішна.')

    request_handler = DefaultRequestHandler(
        agent_executor=agent_executor, task_store=InMemoryTaskStore()
    )

    a2a_app = A2AStarletteApplication(
        agent_card=agent_card, http_handler=request_handler
    )
    routes = a2a_app.routes()
    routes.append(
        Route(
            path='/authenticate',
            methods=['GET'],
            endpoint=handle_auth,
        )
    )
    app = Starlette(routes=routes)

    uvicorn.run(app, host=host, port=port)


if __name__ == '__main__':
    main()
```

Цей код Python демонструє налаштування A2A-сумісного "Calendar Agent" для перевірки доступності користувача за допомогою Google Calendar. Він включає перевірку API ключів або конфігурацій Vertex AI для цілей аутентифікації. Можливості агента, включаючи навичку "check_availability", визначаються в AgentCard, яка також вказує мережеву адресу агента. Потім створюється ADK агент, налаштований з сервісами в пам'яті для керування артефактами, сеансами та пам'яттю. Код потім ініціалізує веб-додаток Starlette, включає зворотний виклик аутентифікації та обробник протоколу A2A, та виконує його, використовуючи Uvicorn для виставлення агента через HTTP.

Ці приклади ілюструють процес побудови A2A-сумісного агента, від визначення його можливостей до запуску його як веб-сервісу. Використовуючи Agent Cards та ADK, розробники можуть створювати сумісних AI агентів, здатних інтегруватися з інструментами типу Google Calendar. Цей практичний підхід демонструє застосування A2A в установленні багатоагентної екосистеми.

# Дуже коротко

**Що:** Окремі агенти AI, особливо ті, які розроблені на різних фреймворках, часто мають труднощі зі складними багатогранними проблемами самостійно. Основна проблема — це відсутність спільної мови або протоколу, який дозволяє їм ефективно спілкуватися та співпрацювати. Ця ізоляція перешкоджає створенню складних систем, де множинні спеціалізовані агенти можуть об'єднати свої унікальні навички для вирішення великих задач. Без стандартизованого підходу інтеграція цих розрізнених агентів є дорогостоючою, довгочасною та перешкоджає розвитку потужніших, узгоджених рішень AI.

**Чому:** Протокол міжагентної комунікації (A2A) надає відкрите, стандартизоване рішення для цієї проблеми. Це HTTP-заснований протокол, який забезпечує сумісність, дозволяючи різним AI агентам координувати, делегувати задачи та ділитися інформацією безшовно, незалежно від їхної базової технології. Основним компонентом є Agent Card, файл цифрової ідентичності, який описує можливості агента, навички та endpoints комунікації, полегшуючи виявлення та взаємодію. A2A визначає різні механізми взаємодії, включаючи синхронну та асинхронну комунікацію, для підтримки розмаїтих сценаріїв використання. Створюючи універсальний стандарт для співпраці агентів, A2A сприяє модульній та масштабованій екосистемі для побудови складних багатоагентних агентних систем.

**Правило великого пальця:** Використовуйте цей паттерн, коли вам потрібно оркеструвати співпрацю між двома або більше AI агентами, особливо якщо вони розроблені з використанням різних фреймворків (наприклад, Google ADK, LangGraph, CrewAI). Він ідеальний для побудови складних, модульних додатків, де спеціалізовані агенти обробляють конкретні частини робочого процесу, такі як делегування аналізу даних одному агенту та генерування звіту іншому. Цей паттерн також істотний, коли агенту потрібно динамічно виявляти та споживати можливості інших агентів для завершення задачі.

**Візуальне резюме**

![][image1]

Рис.2: Паттерн міжагентної комунікації A2A

# Ключові висновки

- Протокол Google A2A являє собою відкритий, HTTP-заснований стандарт, який полегшує комунікацію та співпрацю між AI агентами, розробленими з різними фреймворками.
- AgentCard служить цифровим ідентифікатором агента, дозволяючи автоматичне виявлення та розуміння його можливостей іншими агентами.
- A2A пропонує як синхронну request-response взаємодію (використовуючи `tasks/send`), так і потокові оновлення (використовуючи `tasks/sendSubscribe`) для задоволення різноманітних потреб комунікації.
- Протокол підтримує мультиповоротні розмови, включаючи стан `input-required`, який дозволяє агентам запитувати додаткову інформацію та зберігати контекст під час взаємодій.
- A2A заохочує модульну архітектуру, де спеціалізовані агенти можуть працювати незалежно на різних портах, забезпечуючи масштабованість та розподіленість системи.
- Інструменти типу Trickle AI допомагають у візуалізації та відстеженні A2A комунікацій, що допомагає розробникам мовніторити, налагоджувати та оптимізувати багатоагентні системи.
- Хоча A2A являє собою високорівневий протокол для управління задачами та робочими процесами між різними агентами, Model Context Protocol (MCP) надає стандартизований інтерфейс для LLM для взаємодії з зовнішніми ресурсами.

# Висновок

Протокол міжагентної комунікації (A2A) встановлює вітальний, відкритий стандарт для подолання присутної ізоляції окремих агентів AI. Надаючи спільний HTTP-заснований фреймворк, він забезпечує безшовну співпрацю та сумісність між агентами, розробленими на різних платформах, таких як Google ADK, LangGraph або CrewAI. Основним компонентом є Agent Card, яка служить цифровою ідентичністю, ясно визначаючи можливості агента та забезпечуючи динамічне виявлення іншими агентами. Гнучкість протоколу підтримує різні паттерни взаємодії, включаючи синхронні запити, асинхронний polling та потокову передачу в режимі реального часу, задовольняючи широкий спектр потреб додатків.

Це забезпечує створення модульних та масштабованих архітектур, де спеціалізовані агенти можуть бути об'єднані для оркестрування складних автоматизованих робочих процесів. Безпека являє собою фундаментальний аспект, з вбудованими механізмами типу mTLS та явними вимогами аутентифікації для захисту комунікацій. Доповнюючи інші стандарти типу MCP, унікальний фокус A2A на високорівневій координації та делегуванні задач між агентами. Сильна підтримка від великих технологічних компаній та доступність практичних реалізацій підкреслюють його зростаючу важливість. Цей протокол прокладає шлях розробникам для побудови більш складних, розподілених та інтелектуальних багатоагентних систем. У кінцевому рахунку, A2A являє собою фундаментальний стовп для створення інноваційної та сумісної екосистеми спільного AI.

# Література

1. Chen, B. (2025, April 22). _Як побудувати свій перший проект Google A2A: Покроковий посібник_. Trickle.so Blog. https://www.trickle.so/blog/how-to-build-google-a2a-project
2. Google A2A GitHub Repository. https://github.com/google-a2a/A2A
3. Google Agent Development Kit (ADK) https://google.github.io/adk-docs/
4. Getting Started with Agent-to-Agent (A2A) Protocol: https://codelabs.developers.google.com/intro-a2a-purchasing-concierge#0
5. Google AgentDiscovery - https://a2a-protocol.org/latest/
6. Communication between different AI frameworks such as LangGraph, CrewAI, and Google ADK https://www.trickle.so/blog/how-to-build-google-a2a-project
7. Designing Collaborative Multi-Agent Systems with the A2A Protocol https://www.oreilly.com/radar/designing-collaborative-multi-agent-systems-with-the-a2a-protocol/

[image1]: ../Assets/chapter-15-image1.png
[image2]: ../Assets/chapter-15-image2.png

---

## Навігація

**Назад:** [Розділ 14. Вилучення знань](../Частина%203/Розділ%2014.%20Вилучення%20знань.md)<br>
**Вперед:** [Розділ 16. Оптимізація з урахуванням ресурсів](Розділ%2016.%20Оптимізація%20з%20урахуванням%20ресурсів.md)
