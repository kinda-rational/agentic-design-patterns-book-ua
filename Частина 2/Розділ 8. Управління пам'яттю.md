# Розділ 8: Управління пам'яттю

Ефективне управління пам'яттю є надзвичайно важливим для інтелектуальних агентів, щоб зберігати інформацію. Агентам потрібні різні типи пам'яті, як і людям, для ефективної роботи. У цьому розділі розглядається управління пам'яттю, зокрема вимоги агентів до немедленної (короткострокової) та постійної (довгострокової) пам'яті.

У агентних системах пам'ять означає здатність агента зберігати та використовувати інформацію з минулих взаємодій, спостережень та досвіду навчання. Ця можливість дозволяє агентам приймати обґрунтовані рішення, підтримувати контекст розмови та поліпшуватися з часом. Пам'ять агентів зазвичай поділяється на два основні типи:

- **Короткострокова пам'ять (контекстна пам'ять):** Подібно робочій пам'яті, вона зберігає інформацію, яка в даний момент обробляється або нещодавно була доступна. Для агентів, що використовують великі мовні моделі (LLM), короткострокова пам'ять в основному існує в контекстному вікні. Це вікно містить останні повідомлення, відповіді агента, результати використання інструментів та рефлексію агента з поточної взаємодії, все це інформує подальші відповіді та дії LLM. Контекстне вікно має обмежену ємність, що обмежує кількість недавної інформації, до якої агент може мати прямий доступ. Ефективне управління короткостроковою пам'яттю включає збереження найбільш релевантної інформації в цьому обмеженому просторі, можливо, з використанням таких методів, як підсумовування старих сегментів розмови або виділення ключових деталей. Поява моделей з "довгими контекстними" вікнами просто розширює розмір цієї короткострокової пам'яті, дозволяючи зберігати більше інформації в межах однієї взаємодії. Однак цей контекст все ще є тимчасовим і втрачається після завершення сесії, а його обробка може бути дорогою та неефективною щоразу. Отже, агентам потрібні окремі типи пам'яті для досягнення справжньої постійності, спогадів про інформацію з минулих взаємодій та побудови тривалої бази знань.

- **Довгострокова пам'ять (постійна пам'ять):** Вона діє як хранилище інформації, яку агентам необхідно зберігати в різних взаємодіях, завданнях або протягом тривалих періодів, подібно до довгострокових баз знань. Дані зазвичай зберігаються поза безпосередньою обробленням агента, часто в базах даних, графах знань або векторних базах даних. У векторних базах даних інформація перетворюється на числові вектори та зберігається, що дозволяє агентам вилучати дані на основі семантичної подібності, а не точного збігу ключових слів — процес, відомий як семантичний пошук. Коли агенту потрібна інформація з довгострокової пам'яті, він запитує зовнішнє сховище, вилучає релевантні дані та інтегрує їх у короткостроковий контекст для негайного використання, таким чином поєднуючи попередні знання з поточною взаємодією.

# Практичні застосування та випадки використання

Управління пам'яттю є важливим для агентів, щоб відслідковувати інформацію та інтелектуально працювати з часом. Це необхідно агентам для перевищення базових можливостей відповідей на питання. Застосування включають:

- **Чат-боти та розмовний ШІ:** Підтримання потоку розмови залежить від короткострокової пам'яті. Чат-ботам потрібно пам'ятати попередні користувацькі введення для надання зв'язних відповідей. Довгострокова пам'ять дозволяє чат-ботам вспомінати користувацькі переваги, минулі проблеми або попередні дискусії, пропонуючи персоналізовані та безперервні взаємодії.

- **Агенти, орієнтовані на завдання:** Агенти, що керують багатокроковими завданнями, потребують короткострокової пам'яті для відслідковування попередніх кроків, поточного прогресу та загальних цілей. Ця інформація може знаходитися в контексті завдання або тимчасовому сховищі. Довгострокова пам'ять критично важлива для доступу до конкретних даних користувача, які не знаходяться в безпосередньому контексті.

- **Персоналізовані досвіди:** Агенти, що пропонують індивідуальні взаємодії, використовують довгострокову пам'ять для зберігання та вилучення користувацьких переваг, минулої поведінки та особистої інформації. Це дозволяє агентам адаптувати свої відповіді та пропозиції.

- **Навчання та поліпшення:** Агенти можуть поліпшити свою продуктивність, навчаючись на минулих взаємодіях. Успішні стратегії, помилки та нова інформація зберігаються в довгостроковій пам'яті, сприяючи майбутнім адаптаціям. Агенти навчання з підкріпленням зберігають вивчені стратегії або знання таким чином.

- **Пошук інформації (RAG):** Агенти, призначені для відповідей на питання, мають доступ до бази знань — своєї довгострокової пам'яті, часто реалізованої за допомогою Retrieval Augmented Generation (RAG). Агент вилучає релевантні документи або дані для інформування своїх відповідей.

- **Автономні системи:** Роботи або самкеровані автомобілі потребують пам'яті для карт, маршрутів, розташування об'єктів та вивченої поведінки. Це включає коротку пам'ять для безпосереднього оточення та довгу пам'ять для загальних знань про оточення.

Пам'ять дозволяє агентам підтримувати історію, навчатися, персоналізувати взаємодії та управляти складними, часозалежними проблемами.

# Практичний код: Управління пам'яттю в Google Agent Developer Kit (ADK)

Google Agent Developer Kit (ADK) пропонує структурований метод управління контекстом та пам'яттю, включаючи компоненти для практичного застосування. Твердого розуміння Session, State та Memory в ADK надзвичайно важливо для створення агентів, які повинні зберігати інформацію.

Як і в людських взаємодіях, агентам потрібна здатність вспомінати попередні обміни для ведення зв'язних та природних розмов. ADK спрощує управління контекстом через три основні концепції та пов'язані з ними сервіси.

Кожну взаємодію з агентом можна розглядати як унікальну нитку розмови. Агентам може знадобитися доступ до даних з більш ранніх взаємодій. ADK структурує це наступним чином:

- **Session:** Індивідуальна нитка чату, яка реєструє повідомлення та дії (Events) для цієї конкретної взаємодії, також зберігаючи тимчасові дані (State), релевантні для цієї розмови.
- **State (session.state):** Дані, збережені в Session, що містять інформацію, релевантну тільки для поточної активної нитки чату.
- **Memory:** Пошукове хранилище інформації, отриманої з різних минулих чатів або зовнішніх джерел, що служить ресурсом для вилучення даних поза безпосередньою розмовою.

ADK надає спеціалізовані сервіси для управління критично важливими компонентами, необхідними для створення складних, стану збереження та контексту, що можуть бути обізнаними агентів. SessionService керує нитками чату (об'єкти Session), обробляючи їх ініціалізацію, запис та завершення, тоді як MemoryService контролює збереження та вилучення довгострокових знань (Memory).

Як SessionService, так і MemoryService пропонують різні варіанти конфігурації, дозволяючи користувачам вибирати методи зберігання залежно від потреб додатку. Доступні варіанти в пам'яті для цілей тестування, хоча дані не будуть збережені при перезавантаженні. Для постійного зберігання та масштабованості ADK також підтримує бази даних та хмарні сервіси.

## Session: Відстеження кожного чату

Об'єкт Session в ADK призначений для відстеження та управління індивідуальними нитками чату. При ініціалізації розмови з агентом SessionService генерує об'єкт Session, представлений як `google.adk.sessions.Session`. Цей об'єкт інкапсулює всі дані, релевантні для конкретної нитки розмови, включаючи унікальні ідентифікатори (id, app_name, user_id), хронологічну запис подій як об'єкти Event, область зберігання для тимчасових даних, специфічних для сесії, відомої як state, та тимчасову мітку, що вказує на останнє оновлення (last_update_time). Розробники зазвичай взаємодіють з об'єктами Session непрямо через SessionService. SessionService відповідає за управління життєвим циклом сесій розмови, що включає ініціалізацію нових сесій, возобновлення попередніх сесій, запис активності сесії (включаючи оновлення стану), ідентифікацію активних сесій та управління видаленням даних сесії. ADK надає кілька реалізацій SessionService з різними механізмами зберігання для історії сесій та тимчасових даних, такі як InMemorySessionService, який підходить для тестування, але не забезпечує постійність даних при перезавантаженні додатку.

```python
# Приклад: Використання InMemorySessionService
# Придатна для локальної розробки та тестування, де постійність даних
# при перезавантаженні додатку не потрібна.
from google.adk.sessions import InMemorySessionService

session_service = InMemorySessionService()
```

Потім є DatabaseSessionService, якщо ви хочете надійне збереження в базу даних, якою ви керуєте.

```python
# Приклад: Використання DatabaseSessionService
# Придатна для продакшену або розробки, що вимагає постійного зберігання.
# Необхідно налаштувати URL бази даних (наприклад, для SQLite, PostgreSQL тощо).
# Вимагає: pip install google-adk[sqlalchemy] та драйвер бази даних (наприклад, psycopg2 для PostgreSQL)
from google.adk.sessions import DatabaseSessionService

# Приклад використання локального файлу SQLite:
db_url = "sqlite:///./my_agent_data.db"
session_service = DatabaseSessionService(db_url=db_url)
```

Крім того, є VertexAiSessionService, який використовує інфраструктуру Vertex AI для масштабованого продакшену на Google Cloud.

```python
# Приклад: Використання VertexAiSessionService
# Придатна для масштабованого продакшену на Google Cloud Platform, використовуючи
# інфраструктуру Vertex AI для управління сесіями.
# Вимагає: pip install google-adk[vertexai] та налаштування/аутентифікацію GCP
from google.adk.sessions import VertexAiSessionService

PROJECT_ID = "your-gcp-project-id"  # Замініть на ваш ID проекту GCP
LOCATION = "us-central1"  # Замініть на бажане місцезнаходження GCP
# app_name, використовуваний з цим сервісом, має відповідати ID або імені Reasoning Engine
REASONING_ENGINE_APP_NAME = "projects/your-gcp-project-id/locations/us-central1/reasoningEngines/your-engine-id"  # Замініть на ім'я ресурсу вашого Reasoning Engine

session_service = VertexAiSessionService(project=PROJECT_ID, location=LOCATION)
# При використанні цього сервісу передавайте REASONING_ENGINE_APP_NAME методам сервісу:
# session_service.create_session(app_name=REASONING_ENGINE_APP_NAME, ...)
# session_service.get_session(app_name=REASONING_ENGINE_APP_NAME, ...)
# session_service.append_event(session, event, app_name=REASONING_ENGINE_APP_NAME)
# session_service.delete_session(app_name=REASONING_ENGINE_APP_NAME, ...)
```

Вибір відповідного SessionService критично важливий, оскільки він визначає, як історія взаємодій агента та тимчасові дані зберігаються та їх постійність.

Кожен обмін повідомленнями включає циклічний процес: отримується повідомлення, Runner вилучає або встановлює Session за допомогою SessionService, агент обробляє повідомлення, використовуючи контекст Session (стан та історичні взаємодії), агент генерує відповідь та може оновити стан, Runner інкапсулює це як Event, та метод session_service.append_event записує нову подію та оновлює стан у сховищі. Session потім очікує наступного повідомлення. В ідеалі метод delete_session використовується для завершення сесії, коли взаємодія закінчується. Цей процес ілюструє, як SessionService підтримує безперервність, керуючи історією та тимчасовими даними, специфічними для Session.

## State: Блокнот Session

В ADK кожна Session, яка представляє нитку чату, включає компонент state, подібний до тимчасової робочої пам'яті агента протягом цієї конкретної розмови. Тоді як session.events реєструє всю історію чату, session.state зберігає та оновлює динамічні точки даних, релевантні для активного чату.

По суті, session.state працює як словник, що зберігає дані як пари ключ-значення. Його основна функція — дозволити агенту зберігати та керувати деталями, необхідними для зв'язної діалогу, такими як користувацькі переваги, прогрес завдань, інкрементальне збирання даних або умовні прапори, що впливають на подальші дії агента.

Структура state складається зі строкових ключів, пов'язаних зі значеннями серіалізованих типів Python, включаючи строки, числа, булеві значення, списки та словники, що містять ці базові типи. State є динамічним, що еволюціонує протягом розмови. Постійність цих змін залежить від налаштованого SessionService.

Організація state може бути досягнута за допомогою префіксів ключів для визначення області даних та постійності. Ключі без префіксів специфічні для сесії.

- Префікс `user:` пов'язує дані з ID користувача в усіх сесіях.
- Префікс `app:` позначає дані, розділені між усіма користувачами додатку.
- Префікс `temp:` вказує на дані, дійсні тільки для поточного ходу обробки і не зберігаються постійно.

Агент отримує доступ до всіх даних state через єдиний словник session.state. SessionService обробляє вилучення, злиття та постійність даних. State повинен оновлюватися при додаванні Event до історії сесії через session_service.append_event(). Це забезпечує точне відстеження, правильне збереження у постійних сервісах та безпечну обробку змін стану.

1. **Простий спосіб: Використання output_key (для текстових відповідей агента):** Це найпростіший метод, якщо ви просто хочете зберегти остаточну текстову відповідь агента безпосередньо в state. Коли ви налаштовуєте свою LlmAgent, просто вказуйте output_key, який ви хочете використовувати. Runner бачить це та автоматично створює необхідні дії для збереження відповіді в state при додаванні події. Розглянемо приклад коду, що демонструє оновлення state через output_key.

```python
# Імпорт необхідних класів з Google Agent Developer Kit (ADK)
from google.adk.agents import LlmAgent
from google.adk.sessions import InMemorySessionService, Session
from google.adk.runners import Runner
from google.genai.types import Content, Part

# Визначення LlmAgent з output_key.
greeting_agent = LlmAgent(
    name="Greeter",
    model="gemini-2.0-flash",
    instruction="Generate a short, friendly greeting.",
    output_key="last_greeting"
)

# --- Налаштування Runner та Session ---
app_name, user_id, session_id = "state_app", "user1", "session1"
session_service = InMemorySessionService()
runner = Runner(
    agent=greeting_agent,
    app_name=app_name,
    session_service=session_service
)
session = session_service.create_session(
    app_name=app_name,
    user_id=user_id,
    session_id=session_id
)

print(f"Initial state: {session.state}")

# --- Запуск агента ---
user_message = Content(parts=[Part(text="Hello")])
print("\n--- Running the agent ---")
for event in runner.run(
    user_id=user_id,
    session_id=session_id,
    new_message=user_message
):
    if event.is_final_response():
        print("Agent responded.")

# --- Перевірка оновленого стану ---
# Правильно перевіряємо стан *після* того, як runner закінчив обробку всіх подій.
updated_session = session_service.get_session(app_name, user_id, session_id)
print(f"\nState after agent run: {updated_session.state}")
```

За кулісами Runner бачить ваш output_key та автоматично створює необхідні дії з state_delta при виклику append_event.

2. **Стандартний спосіб: Використання EventActions.state_delta (для більш складних оновлень):** Для випадків, коли вам потрібно робити більш складні речі — наприклад, оновлювати декілька ключів одночасно, зберігати речі, які не є просто текстом, спрямовуватися на конкретні області, такі як user: або app:, або виконувати оновлення, які не пов'язані з остаточною текстовою відповіддю агента — ви вручну створите словник ваших змін стану (state_delta) та включите його в EventActions події, яку ви додаєте. Розглянемо один приклад:

```python
import time
from google.adk.tools.tool_context import ToolContext
from google.adk.sessions import InMemorySessionService

# --- Визначення рекомендованого підходу на основі інструментів ---
def log_user_login(tool_context: ToolContext) -> dict:
    """
    Оновлює стан сесії при події входу користувача.
    Цей інструмент інкапсулює всі зміни стану, пов'язані з входом користувача.
    Args:
        tool_context: Автоматично надається ADK, дає доступ до стану сесії.
    Returns:
        Словник, що підтверджує успіх дії.
    """
    # Доступ до стану напрямо через наданий контекст.
    state = tool_context.state

    # Отримання поточних значень або значень за замовчуванням, потім оновлення стану.
    # Це набагато чистіше та локалізує логіку.
    login_count = state.get("user:login_count", 0) + 1
    state["user:login_count"] = login_count
    state["task_status"] = "active"
    state["user:last_login_ts"] = time.time()
    state["temp:validation_needed"] = True

    print("State updated from within the `log_user_login` tool.")

    return {
        "status": "success",
        "message": f"User login tracked. Total logins: {login_count}."
    }

# --- Демонстрація використання ---
# У реальному додатку LLM Agent вирішив би викликати цей інструмент.
# Тут ми симулюємо прямий виклик для демонстраційних цілей.

# 1. Налаштування
session_service = InMemorySessionService()
app_name, user_id, session_id = "state_app_tool", "user3", "session3"
session = session_service.create_session(
    app_name=app_name,
    user_id=user_id,
    session_id=session_id,
    state={"user:login_count": 0, "task_status": "idle"}
)
print(f"Initial state: {session.state}")

# 2. Симуляція виклику інструменту (у реальному додатку це робить ADK Runner)
# Ми створюємо ToolContext вручну тільки для цього автономного прикладу.
from google.adk.tools.tool_context import InvocationContext
mock_context = ToolContext(
    invocation_context=InvocationContext(
        app_name=app_name, user_id=user_id, session_id=session_id,
        session=session, session_service=session_service
    )
)

# 3. Виконання інструменту
log_user_login(mock_context)

# 4. Перевірка оновленого стану
updated_session = session_service.get_session(app_name, user_id, session_id)
print(f"State after tool execution: {updated_session.state}")

# Очікуваний вихід покаже ту саму зміну стану, що й у випадку "До",
# але організація коду значно чистіша та більш надійна.
```

Цей код демонструє підхід на основі інструментів для управління станом користувацької сесії в додатку. Він визначає функцію `log_user_login`, яка діє як інструмент. Цей інструмент відповідає за оновлення стану сесії при вході користувача.

Функція приймає об'єкт `ToolContext`, наданий ADK, для доступу та зміни словника стану сесії. Всередині інструменту вона збільшує `user:login_count`, встановлює `task_status` у "active", записує `user:last_login_ts` (мітку часу) та додає тимчасовий прапор `temp:validation_needed`.

Демонстраційна частина коду симулює, як цей інструмент буде використовуватися. Вона налаштовує сервіс сесій в пам'яті та створює початкову сесію з деяким попередньо визначеним станом. Потім вручну створюється `ToolContext` для імітації середовища, в якому ADK Runner виконав би інструмент. Функція `log_user_login` викликається з цим мок-контекстом. Нарешті, код знову отримує сесію, щоб показати, що стан був оновлений виконанням інструменту. Мета полягає в тому, щоб показати, як інкапсуляція змін стану в інструментах робить код чистішим та більш організованим порівняно з прямим маніпулюванням стану поза інструментами.

Зверніть увагу, що прямої зміни словника `session.state` після отримання сесії вирішено не рекомендується, оскільки це обходить стандартний механізм обробки подій. Такі прямі зміни не будуть записані в історію подій сесії, можуть не бути збережені вибраним `SessionService`, можуть привести до проблем конкурентності та не оновлять важливі метаданні, такі як часові мітки. Рекомендовані методи оновлення стану сесії — використання параметра `output_key` на `LlmAgent` (спеціально для остаточних текстових відповідей агента) або включення змін стану в `EventActions.state_delta` при додаванні події через `session_service.append_event()`. `session.state` повинен в основному використовуватися для читання існуючих даних.

На висновок, при розробці вашого стану тримайте його простим, використовуйте базові типи даних, давайте своїм ключам чіткі імена та правильно використовуйте префікси, уникайте глибокої вкладеності та завжди оновлюйте стан, використовуючи процес append_event.

## Memory: Довгострокові знання з MemoryService

У агентних системах компонент Session підтримує запис поточної історії чату (події) та тимчасових даних (стан), специфічних для однієї розмови. Однак для агентів, щоб зберігати інформацію через множинні взаємодії або мати доступ до зовнішніх даних, потрібне управління довгостроковими знаннями. Це забезпечується MemoryService.

```python
# Приклад: Використання InMemoryMemoryService
# Придатна для локальної розробки та тестування, де постійність даних
# при перезавантаженні додатку не потрібна.
# Вміст пам'яті втрачається при зупинці додатку.
from google.adk.memory import InMemoryMemoryService

memory_service = InMemoryMemoryService()
```

Session та State можна концептуалізувати як коротку пам'ять для однієї сесії чату, тоді як довгострокові знання, керовані MemoryService, функціонують як постійне та пошукове сховище. Це сховище може містити інформацію з множинних минулих взаємодій або зовнішніх джерел. MemoryService, як визначено інтерфейсом BaseMemoryService, встановлює стандарт для управління цими пошуковими довгостроковими знаннями. Його основні функції включають додавання інформації, яка включає вилучення контенту з сесії та його збереження за допомогою методу add_session_to_memory, та вилучення інформації, яке дозволяє агенту запросити сховище та отримати релевантні дані за допомогою методу search_memory.

ADK пропонує кілька реалізацій для створення цього сховища довгострокових знань. InMemoryMemoryService надає тимчасове рішення для зберігання, придатне для цілей тестування, але дані не зберігаються при перезавантаженні додатку. Для виробничих середовищ зазвичай використовується VertexAiRagMemoryService. Цей сервіс використовує сервіс Retrieval Augmented Generation (RAG) Google Cloud, забезпечуючи масштабовані, постійні можливості семантичного пошуку (також див. розділ 14 про RAG).

```python
# Приклад: Використання VertexAiRagMemoryService
# Придатна для масштабованого продакшену на GCP, використовуючи
# Vertex AI RAG (Retrieval Augmented Generation) для постійної,
# пошукової пам'яті.
# Вимагає: pip install google-adk[vertexai], налаштування/аутентифікацію GCP
# та Vertex AI RAG Corpus.
from google.adk.memory import VertexAiRagMemoryService

# Ім'я ресурсу вашого Vertex AI RAG Corpus
RAG_CORPUS_RESOURCE_NAME = "projects/your-gcp-project-id/locations/us-central1/ragCorpora/your-corpus-id"  # Замініть на ім'я ресурсу вашого Corpus

# Додаткова конфігурація для поведінки вилучення
SIMILARITY_TOP_K = 5  # Кількість топ-результатів для вилучення
VECTOR_DISTANCE_THRESHOLD = 0.7  # Поріг для векторної подібності

memory_service = VertexAiRagMemoryService(
    rag_corpus=RAG_CORPUS_RESOURCE_NAME,
    similarity_top_k=SIMILARITY_TOP_K,
    vector_distance_threshold=VECTOR_DISTANCE_THRESHOLD
)
# При використанні цього сервісу методи, такі як add_session_to_memory
# та search_memory, будуть взаємодіяти з указаним Vertex AI
# RAG Corpus.
```

# Практичний код: Управління пам'яттю в LangChain та LangGraph

У LangChain та LangGraph пам'ять є критичним компонентом для створення інтелектуальних та природно відчутих розмовних додатків. Вона дозволяє агенту ШІ запам'ятовувати інформацію з минулих взаємодій, навчатися на зворотному зв'язку та адаптуватися до користувацьких переваг. Функція пам'яті LangChain забезпечує основу для цього, посилаючись на збережену історію для збагачення поточних промптів та потім записуючи останній обмін для майбутнього використання. Коли агенти обробляють більш складні завдання, ця можливість стає необхідною як для ефективності, так і для задоволення користувачів.

**Короткострокова пам'ять:** Це область дії потоку, що означає, що вона відслідковує поточну розмову в межах однієї сесії або потоку. Вона забезпечує негайний контекст, але повна історія може перевантажити контекстне вікно LLM, потенційно призводячи до помилок або поганої продуктивності. LangGraph керує короткостроковою пам'яттю як частиною стану агента, яка зберігається через checkpointer, дозволяючи возобновити потік в будь-який час.

**Довгострокова пам'ять:** Це зберігає користувацькі або дані рівня додатку через сесії та розділяється між розмовними потоками. Вона зберігається в користувацьких "просторах імен" та може бути викликана в будь-який час у будь-якому потоці. LangGraph надає сховища для збереження та виклику довгострокової пам'яті, дозволяючи агентам зберігати знання невизначений час.

LangChain надає кілька інструментів для управління історією розмов, від ручного контролю до автоматизованої інтеграції в ланцюги.

**ChatMessageHistory: Ручне управління пам'яттю.** Для прямого та простого контролю над історією розмови поза формальним ланцюгом клас ChatMessageHistory є ідеальним. Це дозволяє ручне відстеження обмінів діалогів.

```python
from langchain.memory import ChatMessageHistory

# Ініціалізація об'єкта історії
history = ChatMessageHistory()

# Додавання повідомлень користувача та ШІ
history.add_user_message("Я спрямовуюся в Нью-Йорк наступного тижня.")
history.add_ai_message("Відмінно! Це фантастичне місто.")

# Доступ до списку повідомлень
print(history.messages)
```

**ConversationBufferMemory: Автоматизована пам'ять для ланцюгів.** Для інтеграції пам'яті безпосередньо в ланцюги ConversationBufferMemory є поширеним вибором. Вона містить буфер розмови та робить його доступним для вашого промпта. Її поведінка може бути налаштована за допомогою двох ключових параметрів:

- `memory_key`: Строка, яка вказує на ім'я змінної у вашому промпті, яка міститиме історію чату. За замовчуванням "history".
- `return_messages`: Булеве значення, яке диктує формат історії.
  - Якщо False (за замовчуванням), вона повертає одну відформатовану строку, яка ідеальна для стандартних LLM.
  - Якщо True, вона повертає список об'єктів повідомлень, що є рекомендованим форматом для чат-моделей.

```python
from langchain.memory import ConversationBufferMemory

# Ініціалізація пам'яті
memory = ConversationBufferMemory()

# Збереження ходу розмови
memory.save_context({"input": "Яка погода?"}, {"output": "Сьогодні сонячно."})

# Завантаження пам'яті як строки
print(memory.load_memory_variables({}))
```

Інтеграція цієї пам'яті в LLMChain дозволяє моделі отримати доступ до історії розмови та надати контекстуально релевантні відповіді:

```python
from langchain_openai import OpenAI
from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate
from langchain.memory import ConversationBufferMemory

# 1. Визначення LLM та Prompt
llm = OpenAI(temperature=0)
template = """Ви корисний туристичний агент.

Попередня розмова:
{history}

Нове питання: {question}
Відповідь:"""
prompt = PromptTemplate.from_template(template)

# 2. Конфігурація пам'яті
# memory_key "history" відповідає змінній у промпті
memory = ConversationBufferMemory(memory_key="history")

# 3. Побудова ланцюга
conversation = LLMChain(llm=llm, prompt=prompt, memory=memory)

# 4. Запуск розмови
response = conversation.predict(question="Я хочу забронювати рейс.")
print(response)
response = conversation.predict(question="Кстаті, мене звуть Сем.")
print(response)
response = conversation.predict(question="Як мене звали знову?")
print(response)
```

Для поліпшеної ефективності з чат-моделями рекомендується використовувати структурований список об'єктів повідомлень, установивши `return_messages=True`.

```python
from langchain_openai import ChatOpenAI
from langchain.chains import LLMChain
from langchain.memory import ConversationBufferMemory
from langchain_core.prompts import (
    ChatPromptTemplate,
    MessagesPlaceholder,
    SystemMessagePromptTemplate,
    HumanMessagePromptTemplate,
)

# 1. Визначення чат-моделі та промпта
llm = ChatOpenAI()
prompt = ChatPromptTemplate(
    messages=[
        SystemMessagePromptTemplate.from_template("Ви дружелюбний помічник."),
        MessagesPlaceholder(variable_name="chat_history"),
        HumanMessagePromptTemplate.from_template("{question}")
    ]
)

# 2. Конфігурація пам'яті
# return_messages=True необхідна для чат-моделей
memory = ConversationBufferMemory(memory_key="chat_history", return_messages=True)

# 3. Побудова ланцюга
conversation = LLMChain(llm=llm, prompt=prompt, memory=memory)

# 4. Запуск розмови
response = conversation.predict(question="Привіт, я Джейн.")
print(response)
response = conversation.predict(question="Пам'ятаєте моє ім'я?")
print(response)
```

**Типи довгострокової пам'яті:** Довгострокова пам'ять дозволяє системам зберігати інформацію через різні розмови, забезпечуючи глибший рівень контексту та персоналізації. Вона може бути розділена на три типи, аналогічні людській пам'яті:

- **Семантична пам'ять: Запам'ятовування фактів:** Це включає збереження конкретних фактів та концепцій, таких як користувацькі переваги або знання предметної галузі. Вона використовується для обґрунтування відповідей агента, призводячи до більш персоналізованих та релевантних взаємодій. Ця інформація може керуватися як постійно оновлюваний користувацький "профіль" (JSON-документ) або як "колекція" окремих фактичних документів.

- **Епізодична пам'ять: Запам'ятовування досвіду:** Це включає вспомин про минулі події або дії. Для ШІ-агентів епізодична пам'ять часто використовується для запам'ятовування того, як виконати завдання. На практиці вона часто реалізується через few-shot example prompting, де агент навчається на минулих успішних послідовностях взаємодій для правильного виконання завдань.

- **Процедурна пам'ять: Запам'ятовування правил:** Це пам'ять про те, як виконувати завдання — основні інструкції та поведінка агента, часто містяться в його системному промпті. Для агентів зазвичай змінювати свої власні промпти для адаптації та поліпшення. Ефективна техніка — "Рефлексія", де агент отримує промпт зі своїми поточними інструкціями та недавніми взаємодіями, потім його просять уточнити свої власні інструкції.

Нижче наведено псевдокод, що демонструє, як агент може використовувати рефлексію для оновлення своєї процедурної пам'яті, збереженої в LangGraph BaseStore:

```python
# Вузол, який оновлює інструкції агента
def update_instructions(state: State, store: BaseStore):
    namespace = ("instructions",)
    # Отримання поточних інструкцій зі сховища
    current_instructions = store.search(namespace)[0]

    # Створення промпта для запиту LLM рефлексії над розмовою
    # та генерування нових, поліпшених інструкцій
    prompt = prompt_template.format(
        instructions=current_instructions.value["instructions"],
        conversation=state["messages"]
    )

    # Отримання нових інструкцій від LLM
    output = llm.invoke(prompt)
    new_instructions = output['new_instructions']

    # Збереження оновлених інструкцій назад у сховище
    store.put(("agent_instructions",), "agent_a", {"instructions": new_instructions})

# Вузол, який використовує інструкції для генерування відповіді
def call_model(state: State, store: BaseStore):
    namespace = ("agent_instructions", )
    # Вилучення останніх інструкцій зі сховища
    instructions = store.get(namespace, key="agent_a")[0]

    # Використання вилучених інструкцій для форматування промпта
    prompt = prompt_template.format(instructions=instructions.value["instructions"])
    # ... логіка додатку продовжується
```

LangGraph зберігає довгострокову пам'ять як JSON-документи у сховищі. Кожна пам'ять організована під користувацьким простором імен (як папка) та окремим ключем (як ім'я файлу). Ця ієрархічна структура дозволяє легко організувати та вилучити інформацію. Наступний код демонструє, як використовувати InMemoryStore для розміщення, отримання та пошуку пам'яті.

```python
from langgraph.store.memory import InMemoryStore

# Заповнювач для реальної функції вбудовування
def embed(texts: list[str]) -> list[list[float]]:
    # У реальному додатку використовуйте відповідну модель вбудовування
    return [[1.0, 2.0] for _ in texts]

# Ініціалізація сховища в пам'яті. Для продакшену використовуйте сховище на основі бази даних.
store = InMemoryStore(index={"embed": embed, "dims": 2})

# Визначення простору імен для конкретного користувача та контексту додатку
user_id = "my-user"
application_context = "chitchat"
namespace = (user_id, application_context)

# 1. Розміщення пам'яті у сховищі
store.put(
    namespace,
    "a-memory",  # Ключ для цієї пам'яті
    {
        "rules": [
            "Користувач люб ить коротку, пряму мову",
            "Користувач говорить тільки англійською та python",
        ],
        "my-key": "my-value",
    },
)

# 2. Отримання пам'яті за його простором імен та ключем
item = store.get(namespace, "a-memory")
print("Retrieved Item:", item)

# 3. Пошук пам'яті у просторі імен, фільтрування за вмістом
# та сортування за векторною подібністю з запитом.
items = store.search(
    namespace,
    filter={"my-key": "my-value"},
    query="мовні переваги"
)
print("Search Results:", items)
```

# Vertex Memory Bank

Memory Bank — керований сервіс у Vertex AI Agent Engine, що надає агентам постійну довгострокову пам'ять. Сервіс використовує моделі Gemini для асинхронного аналізу історій розмов для вилучення ключових фактів та користувацьких переваг.

Ця інформація зберігається постійно, організована за визначеною областю, такою як ID користувача, та інтелектуально оновлена для консолідації нових даних та вирішення суперечностей. При початку нової сесії агент вилучає релевантну пам'ять через повне отримання даних або пошук за подібністю з використанням вбудовування. Цей процес дозволяє агенту підтримувати безперервність між сесіями та персоналізувати відповіді на основі вспомненої інформації.

Runner агента взаємодіє з VertexAiMemoryBankService, який спочатку ініціалізується. Цей сервіс обробляє автоматичне збереження пам'яті, створеної під час розмов агента. Кожна пам'ять позначається унікальним USER_ID та APP_NAME, забезпечуючи точне вилучення в майбутньому.

```python
from google.adk.memory import VertexAiMemoryBankService

agent_engine_id = agent_engine.api_resource.name.split("/")[-1]

memory_service = VertexAiMemoryBankService(
    project="PROJECT_ID",
    location="LOCATION",
    agent_engine_id=agent_engine_id
)

session = await session_service.get_session(
    app_name=app_name,
    user_id="USER_ID",
    session_id=session.id
)
await memory_service.add_session_to_memory(session)
```

Memory Bank пропонує беззамітну інтеграцію з Google ADK, забезпечуючи негайний готовий до використання досвід. Для користувачів інших агентних фреймворків, таких як LangGraph та CrewAI, Memory Bank також пропонує підтримку через прямі API-виклики. Онлайн-приклади коду, що демонструють ці інтеграції, легко доступні для зацікавлених читачів.

# З першого погляду

**Що:** Агентні системи повинні запам'ятовувати інформацію з минулих взаємодій для виконання складних завдань та надання зв'язних досвідів. Без механізму пам'яті агенти є без стану, неспроможні підтримувати контекст розмови, навчатися на досвіді або персоналізувати відповіді для користувачів. Це принципово обмежує їх простими одноразовими взаємодіями, не справляючись з багатокроковими процесами або розвивальними потребами користувачів. Основна проблема полягає в тому, як ефективно керувати як негайною тимчасовою інформацією однієї розмови, так і великими постійними знаннями, зібраними з часом.

**Чому:** Стандартизоване рішення — реалізація двокомпонентної системи пам'яті, яка розрізняє коротку та довгу пам'ять. Короткострокова контекстна пам'ять містить недавні дані взаємодій у контекстному вікні LLM для підтримання потоку розмови. Для інформації, яка повинна зберігатися, рішення довгострокової пам'яті використовують зовнішні бази даних, часто векторні сховища, для ефективного семантичного вилучення. Агентні фреймворки, такі як Google ADK, надають конкретні компоненти для керування цим, такі як Session для потоку розмови та State для її тимчасових даних. Спеціалізований MemoryService використовується для інтерфейсу з базою довгострокових знань, дозволяючи агенту вилучати та включати релевантну минулу інформацію в його поточний контекст.

**Емпіричне правило:** Використовуйте цей паттерн, коли агенту потрібно робити більше, ніж відповідати на одне питання. Це необхідно для агентів, які повинні підтримувати контекст протягом розмови, відслідковувати прогрес у багатокрокових завданнях або персоналізувати взаємодії, запам'ятовуючи користувацькі переваги та історію. Реалізуйте управління пам'яттю, коли агент, як очікується, буде навчатися або адаптуватися на основі минулих успіхів, невдач або нової інформації, отриманої.

**Візуальне резюме**

![][image1]

Рис.1: Паттерн проектування управління пам'яттю

# Ключові висновки

Щоб швидко резюмувати основні моменти управління пам'яттю:

- Пам'ять надзвичайно важлива для агентів для відслідковування речей, навчання та персоналізації взаємодій.
- Розмовний ШІ опирається як на коротку пам'ять для негайного контексту в межах одного чату, так і на довгу пам'ять для постійних знань через множинні сесії.
- Короткострокова пам'ять (негайні речі) є тимчасовою, часто обмеженою контекстним вікном LLM або тим, як фреймворк передає контекст.
- Довгострокова пам'ять (речі, що залишаються) зберігає інформацію через різні чати, використовуючи зовнішнє зберігання, таке як векторні бази даних, та доступна через пошук.
- Фреймворки, такі як ADK, мають конкретні частини, такі як Session (потік чату), State (тимчасові дані чату) та MemoryService (пошукові довгострокові знання) для управління пам'яттю.
- SessionService ADK обробляє все життя сесії чату, включаючи її історію (события) та тимчасові дані (стан).
- session.state ADK — це словник для тимчасових даних чату. Префікси (user:, app:, temp:) розповідають вам, де дані належать і залишаються ли.
- В ADK ви повинні оновлювати стан, використовуючи EventActions.state_delta або output_key при додаванні подій, а не змінюючи словник стану напряму.
- MemoryService ADK призначена для розміщення інформації в довгостроковому сховищі та дозволення агентам її пошуку, часто використовуючи інструменти.
- LangChain пропонує практичні інструменти, такі як ConversationBufferMemory, для автоматичного внесення історії однієї розмови в промпт, дозволяючи агенту вспомнити негайний контекст.
- LangGraph забезпечує продвинуту довгострокову пам'ять, використовуючи сховище для збереження та вилучення семантичних фактів, епізодичних досвідів або навіть оновлюваних процедурних правил через різні користувацькі сесії.
- Memory Bank — це керований сервіс, який надає агентам постійну довгострокову пам'ять, автоматично вилучаючи, зберігаючи та вспомінаючи користувацьку інформацію для забезпечення персоналізованих безперервних розмов через фреймворки, такі як Google ADK, LangGraph та CrewAI.

# Висновок

Цей розділ поглиблено зануривсяв дійсно важливу роботу управління пам'яттю для агентних систем, показуючи різницю між коротким контекстом та знаннями, що залишаються надовго. Ми обговорили, як ці типи пам'яті налаштовуються та де ви їх бачите при створенні більш розумних агентів, які можуть запам'ятовувати речі. Ми детально розглянули, як Google ADK дає вам конкретні частини, такі як Session, State та MemoryService, для обробки цього. Тепер, коли ми розглянули, як агенти можуть запам'ятовувати речі, як короткострокові, так і довгострокові, ми можемо перейти до того, як вони можуть навчатися та адаптуватися. Наступний паттерн "Навчання та адаптація" стосується того, як агент змінює те, як він думає, діє або що він знає, все на основі нового досвіду або даних.

# Посилання

1. [ADK Memory](https://google.github.io/adk-docs/sessions/memory/)
2. [LangGraph Memory](https://langchain-ai.github.io/langgraph/concepts/memory/)
3. [Vertex AI Agent Engine Memory Bank](https://cloud.google.com/blog/products/ai-machine-learning/vertex-ai-memory-bank-in-public-preview)

[image1]: ../Assets/chapter-8-image1.png

---

## Навігація

**Назад:** [Розділ 7. Багатоагентне співробітництво](../Частина%201/Розділ%207.%20Багатоагентне%20співробітництво.md)
**Вперед:** [Розділ 9. Навчання та адаптація](Розділ%209.%20Навчання%20та%20адаптація.md)
