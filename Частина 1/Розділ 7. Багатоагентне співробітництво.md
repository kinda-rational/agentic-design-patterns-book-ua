# Розділ 7: Багатоагентне співробітництво

Хоча архітектура монолітного агента може бути ефективною для чітко визначених завдань, її можливості часто обмежені при зіткненні зі складними завданнями багатьох доменів. Паттерн Багатоагентного colaboração розв'язує ці обмеження шляхом структурування системи як кооперативного ансамблю окремих спеціалізованих агентів. Цей підхід побудований на принципі декомпозиції завдань, де високорівнева ціль розбивається на дискретні підзавдання. Кожне підзавдання потім призначається агенту, що володіє специфічними інструментами, доступом до даних або здатностями до міркування, найбільш придатними для цього завдання.

Наприклад, складний дослідницький запит може бути декомпозований та призначений Research Agent для видобування інформації, Data Analysis Agent для статистичної обробки та Synthesis Agent для генерування остаточного звіту. Ефективність такої системи обумовлена не тільки розподілом праці, але й критично залежить від механізмів міжагентної комунікації. Це вимагає стандартизованого протоколу комунікації та спільної онтології, що дозволяють агентам обмінюватися даними, делегувати підзавдання та координувати свої дії для забезпечення узгодженості остаточного результату.

Ця розподілена архітектура пропонує кілька переваг, включаючи підвищену модульність, масштабованість та надійність, оскільки невдача одного агента не обов'язково призводить до повної невдачі системи. Співробітництво дозволяє досягти синергетичного результату, де колективна продуктивність багатоагентної системи перевищує потенційні можливості будь-якого окремого агента в ансамблі.

## Огляд паттерну Багатоагентного співробітництва

Паттерн Багатоагентного співробітництва включає проектування систем, де множинні незалежні або напів-незалежні агенти працюють разом для досягнення спільної мети. Кожен агент зазвичай має визначену роль, специфічні цілі, узгоджені зі спільним завданням, та потенційно доступ до різних інструментів або баз знань. Сила цього паттерну полягає у взаємодії та синергії між цими агентами.

Співробітництво може приймати різні форми:

- **Послідовні передачі**: Один агент завершує завдання та передає свій результат іншому агенту для наступного кроку в конвеєрі (аналогічно паттерну Планування, але явно включаючи різних агентів).
- **Паралельна обробка**: Множинні агенти працюють над різними частинами проблеми одночасно, та їх результати пізніше об'єднуються.
- **Дебати та консенсус**: Багатоагентне співробітництво, де агенти з різними перспективами та джерелами інформації беруть участь у дискусіях для оцінки варіантів, в кінцевому підсумку досягаючи консенсусу або більш обґрунтованого рішення.
- **Ієрархічні структури**: Агент-менеджер може динамічно делегувати завдання робочим агентам на основі їх доступу до інструментів або можливостей плагінів та синтезувати їх результати. Кожен агент також може обробляти відповідні групи інструментів, а не один агент, обробляючи всі інструменти.
- **Експертні команди**: Агенти зі спеціалізованими знаннями в різних доменах (наприклад, дослідник, письменник, редактор) співпрацюють для створення складного результату.
- **Критик-рецензент**: Агенти створюють первісні результати, такі як плани, чернетки або відповіді. Друга група агентів потім критично оцінює цей результат на відповідність політикам, безпеці, дотриманню вимог, коректності, якості та узгодженню з організаційними цілями. Первісний творець або фінальний агент переглядає результат на основі цього зворотного зв'язку. Цей паттерн особливо ефективний для генерування коду, написання досліджень, перевірки логіки та забезпечення етичного узгодження. Переваги цього підходу включають підвищену надійність, поліпшену якість та знижений ризик галюцинацій або помилок.

Багатоагентна система (див. Рис.1) фундаментально включає визначення ролей та обов'язків агентів, встановлення каналів комунікації, через які агенти обмінюються інформацією, та формулювання потоку завдань або протоколу взаємодії, який керує їхніми спільними зусиллями.

![][image1]

_Рис.1: Приклад багатоагентної системи_

Фреймворки, такі як Crew AI та Google ADK, розроблені для полегшення цієї парадигми, надаючи структури для специфікації агентів, завдань та їх інтерактивних процедур. Цей підхід особливо ефективний для викликів, що вимагають різноманітних спеціалізованих знань, що охоплюють множинні дискретні фази, або використовуючи переваги паралельної обробки та підтвердження інформації між агентами.

## Практичні застосування та випадки використання

Багатоагентне співробітництво є потужним паттерном, застосовним у численних доменах:

- **Комплексні дослідження та аналіз**: Команда агентів може співпрацювати над дослідницьким проектом. Один агент може спеціалізуватися на пошуку в академічних базах даних, інший на резюмуванні знахідок, третій на виявленні тенденцій, а четвертий на синтезі інформації в звіт. Це відображає те, як може працювати людська дослідницька команда.

- **Розробка програмного забезпечення**: Уявіть собі агентів, що співпрацюють над створенням програмного забезпечення. Один агент може бути аналітиком вимог, інший генератором коду, третій тестувальником, а четвертий автором документації. Вони можуть передавати результати між собою для створення та перевірки компонентів.

- **Генерування креативного контенту**: Створення маркетингової кампанії може включати агента дослідження ринку, агента-копірайтера, агента графічного дизайну (використовуючи інструменти генерування зображень) та агента планування в соціальних мережах, що працюють разом.

- **Фінансовий аналіз**: Багатоагентна система може аналізувати фінансові ринки. Агенти можуть спеціалізуватися на отриманні даних про акції, аналізі настроїв новин, виконанні технічного аналізу та генеруванні інвестиційних рекомендацій.

- **Ескалація підтримки клієнтів**: Агент першої лінії підтримки може обробляти первісні запити, ескалюючи складні питання спеціалісту-агенту (наприклад, технічному експерту або спеціалісту з виставлення рахунків) за необхідності, демонструючи послідовну передачу на основі складності проблеми.

- **Оптимізація ланцюга поставок**: Агенти можуть представляти різні вузли у ланцюзі поставок (постачальники, виробники, дистрибутори) та співпрацювати для оптимізації рівнів запасів, логістики та планування у відповідь на мінливий попит або збої.

- **Аналіз мережі та відновлення**: Автономні операції значно виграють від агентної архітектури, особливо в точному визначенні збоїв. Множинні агенти можуть співпрацювати для сортування та відновлення проблем, пропонуючи оптимальні дії. Ці агенти також можуть інтегруватися з традиційними моделями машинного навчання та наборами інструментів, використовуючи існуючі системи та одночасно пропонуючи переваги Generative AI.

Здатність визначати спеціалізованих агентів та тщательно оркеструвати їх взаємозв'язки дозволяє розробникам створювати системи з підвищеною модульністю, масштабованістю та здатністю розв'язувати складності, які були б неподоланні для одного інтегрованого агента.

## Багатоагентне співробітництво: Дослідження взаємозв'язків та структур комунікації

Розуміння складних способів взаємодії та комунікації агентів є фундаментальним для проектування ефективних багатоагентних систем. Як показано на Рис. 2, існує спектр моделей взаємозв'язків та комунікації, від найпростішого сценарію з одним агентом до складних, спеціально розроблених колаборативних фреймворків. Кожна модель представляє унікальні переваги та виклики, що впливають на загальну ефективність, надійність та адаптивність багатоагентної системи.

**1. Один агент:** На найбільш базовому рівні "Один агент" діє автономно без прямої взаємодії або комунікації з іншими сутностями. Хоча ця модель проста у реалізації та управлінні, її можливості від природи обмежені областю та ресурсами окремого агента. Вона придатна для завдань, які можна декомпозувати на незалежні підзавдання, кожне з яких вирішується одним самодостатнім агентом.

**2. Мережа:** Модель "Мережа" представляє значний крок до співробітництва, де множинні агенти взаємодіють один з одним децентралізованим способом. Комунікація зазвичай відбувається один-до-одного, дозволяючи обмін інформацією, ресурсами та навіть завданнями. Ця модель сприяє стійкості, оскільки невдача одного агента не обов'язково паралізує всю систему. Однак управління накладними витратами на комунікацію та забезпечення послідовного прийняття рішень у великій неструктурованій мережі може бути складним.

**3. Супервізор:** У моделі "Супервізор" виділений агент, "супервізор", контролює та координує діяльність групи підпорядкованих агентів. Супервізор діє як центральний вузол для комунікації, розподілу завдань та вирішення конфліктів. Ця ієрархічна структура пропонує чіткі лінії влади та може спростити управління та контроль. Однак вона вносить одну критичну точку невдачі (супервізор) та може стати вузьким місцем, якщо супервізор перевантажений великою кількістю підпорядкованих або складними завданнями.

**4. Супервізор як інструмент:** Ця модель є нюансованим розширенням концепції "Супервізор", де роль супервізора менше пов'язана з прямим командуванням та контролем, а більше з наданням ресурсів, керівництва або аналітичної підтримки іншим агентам. Супервізор може пропонувати інструменти, дані або обчислювальні сервіси, які дозволяють іншим агентам більш ефективно виконувати свої завдання, не обов'язково диктуючи кожну їхню дію. Цей підхід спрямований на використання можливостей супервізора без накладення жорсткого контролю зверху вниз.

**5. Ієрархічна:** Модель "Ієрархічна" розширює концепцію супервізора для створення багаторівневої організаційної структури. Це включає множинні рівні супервізорів, де супервізори вищого рівня контролюють супервізорів нижчого рівня та, в кінцевому підсумку, колекцію операційних агентів на найнижчому рівні. Ця структура добре підходить для складних проблем, які можна декомпозувати на підзавдання, кожне з яких керується конкретним рівнем ієрархії. Вона надає структурований підхід до управління масштабованістю та складністю, дозволяючи розподілене прийняття рішень у визначених межах.

![][image2]

_Рис. 2: Агенти комунікують та взаємодіють різними способами._

**6. Користувацька:** Модель "Користувацька" представляє максимальну гнучкість у проектуванні багатоагентних систем. Вона дозволяє створення унікальних структур взаємозв'язків та комунікації, точно адаптованих до специфічних вимог даної проблеми або додатку. Це може включати гібридні підходи, які об'єднують елементи раніше згаданих моделей, або абсолютно нові дизайни, які виникають з унікальних обмежень та можливостей середовища. Користувальницькі моделі часто виникають з необхідності оптимізації для специфічних метрик продуктивності, обробки високодинамічних середовищ або включення доменно-специфічних знань в архітектуру системи. Проектування та реалізація користувальницьких моделей зазвичай вимагає глибокого розуміння принципів багатоагентних систем та тщательного розгляду протоколів комунікації, механізмів координації та виникаючої поведінки.

На висновок, вибір моделі взаємозв'язків та комунікації для багатоагентної системи є критичним проектним рішенням. Кожна модель пропонує відмінні переваги та недоліки, та оптимальний вибір залежить від таких факторів, як складність завдання, кількість агентів, бажаний рівень автономії, потреба в надійності та прийнятні накладні витрати на комунікацію. Майбутні досягнення у багатоагентних системах ймовірно продовжать дослідити та вдосконалити ці моделі, а також розробити нові парадигми для колаборативного інтелекту.

## Практичний код (CrewAI)

Цей Python код визначає AI-powered команду, що використовує фреймворк CrewAI для генерування блог-посту про тренди AI. Він починається з налаштування середовища, завантаження API ключів з файлу .env. Ядро додатку включає визначення двох агентів: дослідника для пошуку та резюмування трендів AI та письменника для створення блог-посту на основі дослідження.

Відповідно визначаються два завдання: одне для дослідження трендів та інше для написання блог-посту, де завдання написання залежить від результату завдання дослідження. Ці агенти та завдання потім об'єднуються в команду, що указує послідовний процес, де завдання виконуються по порядку. Команда ініціалізується з агентами, завданнями та мовною моделлю (конкретно модель "gemini-2.0-flash"). Основна функція виконує цю команду, використовуючи метод kickoff(), оркеструючи співробітництво між агентами для виробництва бажаного результату. Нарешті, код виводить остаточний результат виконання команди, що є сгенерованим блог-постом.

```python
import os
from dotenv import load_dotenv
from crewai import Agent, Task, Crew, Process
from langchain_google_genai import ChatGoogleGenerativeAI


def setup_environment():
    """Завантажує змінні оточення та перевіряє наявність потрібного API ключа."""
    load_dotenv()
    if not os.getenv("GOOGLE_API_KEY"):
        raise ValueError("GOOGLE_API_KEY не знайдено. Будь ласка, встановіть його у вашому .env файлі.")


def main():
    """
    Ініціалізує та запускає AI команду для створення контенту, використовуючи найновішу модель Gemini.
    """
    setup_environment()

    # Визначаємо мовну модель для використання.
    # Оновлено до моделі з серії Gemini 2.0 для кращої продуктивності та функцій.
    # Для передових (preview) можливостей можна використовувати "gemini-2.5-flash".
    llm = ChatGoogleGenerativeAI(model="gemini-2.0-flash")

    # Визначаємо агентів з специфічними ролями та цілями
    researcher = Agent(
        role='Старший дослідницький аналітик',
        goal='Знайти та резюмувати останні тренди у ШІ.',
        backstory="Ви досвідчений дослідницький аналітик з талантом до виявлення ключових трендів та синтезу інформації.",
        verbose=True,
        allow_delegation=False,
    )

    writer = Agent(
        role='Технічний письменник контенту',
        goal='Написати чіткий та привабливий блог-пост на основі результатів дослідження.',
        backstory="Ви досвідчений письменник, який може перекладати складні технічні теми в доступний контент.",
        verbose=True,
        allow_delegation=False,
    )

    # Визначаємо завдання для агентів
    research_task = Task(
        description="Дослідити топ-3 emerging тренди у Штучному Інтелекті у 2024-2025. Зосередитися на практичному застосуванні та потенційному впливу.",
        expected_output="Детальне резюме топ-3 AI трендів, включаючи ключові моменти та джерела.",
        agent=researcher,
    )

    writing_task = Task(
        description="Написати 500-словний блог-пост на основі результатів дослідження. Пост повинен бути привабливим та легким для розуміння загальною аудиторією.",
        expected_output="Повний 500-словний блог-пост про останні AI тренди.",
        agent=writer,
        context=[research_task],
    )

    # Створюємо команду
    blog_creation_crew = Crew(
        agents=[researcher, writer],
        tasks=[research_task, writing_task],
        process=Process.sequential,
        llm=llm,
        verbose=2  # Встановлюємо verbosity для детальних логів виконання команди
    )

    # Виконуємо команду
    print("## Запуск команди створення блога з Gemini 2.0 Flash... ##")
    try:
        result = blog_creation_crew.kickoff()
        print("\n------------------\n")
        print("## Остаточний результат команди ##")
        print(result)
    except Exception as e:
        print(f"\nСталася несподівана помилка: {e}")


if __name__ == "__main__":
    main()
```

Тепер ми заглиблювальномемся у додаткові приклади в межах фреймворку Google ADK, з особливим акцентом на ієрархічні, паралельні та послідовні парадигми координації, разом з реалізацією агента як операційного інструменту.

## Практичний код (Google ADK)

Наступний приклад коду демонструє встановлення ієрархічної структури агентів у межах Google ADK через створення відношень батько-дитина. Код визначає два типи агентів: LlmAgent та користувацький агент TaskExecutor, похідний від BaseAgent. TaskExecutor розроблений для специфічних, не-LLM завдань та в цьому прикладі просто видає подію "Task finished successfully". LlmAgent з іменем greeter ініціалізується з вказаною моделлю та інструкцією діяти як дружелюбний привіт. Користувацький TaskExecutor створюється як task_doer. Батьківський LlmAgent під назвою coordinator також створюється з моделлю та інструкціями. Інструкції coordinator керують ним делегувати привіти greeter'у та виконання завдань task_doer'у. Greeter та task_doer додаються як під-агенти до coordinator'а, встановлюючи відношення батько-дитина. Код потім стверджує, що ці відношення правильно встановлені. Нарешті, він виводить повідомлення, яке вказує, що ієрархія агентів була успішно створена.

```python
from google.adk.agents import LlmAgent, BaseAgent
from google.adk.agents.invocation_context import InvocationContext
from google.adk.events import Event
from typing import AsyncGenerator


# Коректно реалізуємо користувацького агента, розширюючи BaseAgent
class TaskExecutor(BaseAgent):
    """Спеціалізований агент з користувацькою, не-LLM поведінкою."""
    name: str = "TaskExecutor"
    description: str = "Виконує попередньо визначене завдання."

    async def _run_async_impl(self, context: InvocationContext) -> AsyncGenerator[Event, None]:
        """Користувацька логіка реалізації для завдання."""
        # Тут була б ваша користувацька логіка.
        # Для цього прикладу ми просто видаємо просту подію.
        yield Event(author=self.name, content="Завдання успішно завершено.")


# Визначаємо окремих агентів з правильною ініціалізацією
# LlmAgent вимагає вказування моделі.
greeter = LlmAgent(
    name="Greeter",
    model="gemini-2.0-flash-exp",
    instruction="Ви дружелюбний привіт."
)
task_doer = TaskExecutor()  # Створюємо екземпляр нашого конкретного користувацького агента

# Створюємо батьківського агента та призначаємо його під-агентів
# Опис та інструкції батьківського агента повинні керувати його логікою делегування.
coordinator = LlmAgent(
    name="Coordinator",
    model="gemini-2.0-flash-exp",
    description="Координатор, який може привітати користувачів та виконувати завдання.",
    instruction="Коли просять привітати, делегуй Greeter'у. Коли просять виконати завдання, делегуй TaskExecutor'у.",
    sub_agents=[
        greeter,
        task_doer
    ]
)

# Фреймворк ADK автоматично встановлює відношення батько-дитина.
# Ці твердження пройдуть, якщо перевірити після ініціалізації.
assert greeter.parent_agent == coordinator
assert task_doer.parent_agent == coordinator

print("Ієрархія агентів успішно створена.")
```

Цей виривок коду ілюструє використання LoopAgent у межах фреймворку Google ADK для встановлення ітеративних робочих процесів. Код визначає двох агентів: ConditionChecker та ProcessingStep. ConditionChecker є користувацьким агентом, який перевіряє значення "status" у стані сесії. Якщо "status" дорівнює "completed", ConditionChecker ескалює подію для зупинки цикла. В іншому випадку він видає подію для продовження цикла. ProcessingStep є LlmAgent, що використовує модель "gemini-2.0-flash-exp". Його інструкція — виконати завдання та встановити "status" сесії на "completed", якщо це фінальний крок. LoopAgent з іменем StatusPoller створюється. StatusPoller налаштовується з max_iterations=10. StatusPoller включає як ProcessingStep, так і екземпляр ConditionChecker як під-агентів. LoopAgent буде виконувати під-агентів послідовно до 10 ітерацій, зупиняючись, якщо ConditionChecker виявить, що статус "completed".

```python
import asyncio
from typing import AsyncGenerator
from google.adk.agents import LoopAgent, LlmAgent, BaseAgent
from google.adk.events import Event, EventActions
from google.adk.agents.invocation_context import InvocationContext


# Найкраща практика: Визначаємо користувальницьких агентів як повні, самоописуючі класи.
class ConditionChecker(BaseAgent):
    """Користувацький агент, який перевіряє статус 'completed' у стані сесії."""
    name: str = "ConditionChecker"
    description: str = "Перевіряє, чи завершено процес, та сигналізує циклу зупинитися."

    async def _run_async_impl(
        self, context: InvocationContext
    ) -> AsyncGenerator[Event, None]:
        """Перевіряє стан та видає подію для продовження або зупинки цикла."""
        status = context.session.state.get("status", "pending")
        is_done = (status == "completed")

        if is_done:
            # Ескалюємо для припинення цикла, коли умова виконана.
            yield Event(author=self.name, actions=EventActions(escalate=True))
        else:
            # Видаємо просту подію для продовження цикла.
            yield Event(author=self.name, content="Умова не виконана, продовжуємо цикл.")


# Виправлення: LlmAgent повинен мати модель та чіткі інструкції.
process_step = LlmAgent(
    name="ProcessingStep",
    model="gemini-2.0-flash-exp",
    instruction="Ви крок у довшому процесі. Виконайте своє завдання. Якщо ви фінальний крок, оновіть стан сесії, встановивши 'status' на 'completed'."
)

# LoopAgent оркеструє робочий процес.
poller = LoopAgent(
    name="StatusPoller",
    max_iterations=10,
    sub_agents=[
        process_step,
        ConditionChecker()  # Створюємо екземпляр добре визначеного користувацького агента.
    ]
)

# Цей poller тепер буде виконувати 'process_step'
# а потім 'ConditionChecker'
# повторно, поки статус не стане 'completed' або не пройде 10 ітерацій.
```

Цей виривок коду пояснює паттерн SequentialAgent у межах Google ADK, розроблений для побудови лінійних робочих процесів. Цей код визначає послідовний конвеєр агентів, використовуючи бібліотеку google.adk.agents. Конвеєр складається з двох агентів, step1 та step2. step1 називається "Step1_Fetch", та його результат буде збережено в стані сесії під ключем "data". step2 називається "Step2_Process" та проінструктований аналізувати інформацію, збережену в session.state["data"], та надати резюме. SequentialAgent з іменем "MyPipeline" оркеструє виконання цих під-агентів. Коли конвеєр запускається з початковим вводом, step1 виконується першим. Відповідь від step1 буде збережена в стан сесії під ключем "data". Згодом step2 виконується, використовуючи інформацію, яку step1 помістив у стан согідно його інструкції. Ця структура дозволяє будувати робочі процеси, де результат одного агента стає вводом для наступного. Це загальний паттерн при створенні багатокрокових AI або конвеєрів обробки даних.

```python
from google.adk.agents import SequentialAgent, Agent

# Результат цього агента буде збережено в session.state["data"]
step1 = Agent(name="Step1_Fetch", output_key="data")

# Цей агент буде використовувати дані від попереднього кроку.
# Ми проінструктуємо його, як знайти та використовувати ці дані.
step2 = Agent(
    name="Step2_Process",
    instruction="Проаналізуйте інформацію, знайдену в state['data'], та надайте резюме."
)

pipeline = SequentialAgent(
    name="MyPipeline",
    sub_agents=[step1, step2]
)

# Коли конвеєр запускається з початковим вводом, Step1 виконується,
# його відповідь буде збережена в session.state["data"], та потім
# Step2 виконується, використовуючи інформацію зі стану согідно інструкції.
```

Наступний приклад коду ілюструє паттерн ParallelAgent у межах Google ADK, який полегшує паралельне виконання множинних завдань агентів. data_gatherer розроблений для паралельного запуску двох під-агентів: weather_fetcher та news_fetcher. Агент weather_fetcher проінструктований отримати погоду для даного місцезнаходження та зберегти результат в session.state["weather_data"]. Аналогічно, агент news_fetcher проінструктований отримати топ новину для даної теми та зберегти її в session.state["news_data"]. Кожен під-агент налаштований використовувати модель "gemini-2.0-flash-exp". ParallelAgent оркеструє виконання цих під-агентів, дозволяючи їм працювати паралельно. Результати від weather_fetcher та news_fetcher будуть зібрані та збережені у стані сесії. Нарешті, приклад показує, як отримати доступ до зібраних даних про погоду та новини з final_state після завершення виконання агента.

```python
from google.adk.agents import Agent, ParallelAgent

# Краще визначити логіку отримання як інструменти для агентів
# Для простоти в цьому прикладі ми встроїмо логіку в інструкцію агента.
# У реальному сценарії ви б використовували інструменти.

# Визначаємо окремих агентів, які будуть працювати паралельно
weather_fetcher = Agent(
    name="weather_fetcher",
    model="gemini-2.0-flash-exp",
    instruction="Отримайте погоду для даного місцезнаходження та верніть тільки прогноз погоди.",
    output_key="weather_data"  # Результат буде збережено в session.state["weather_data"]
)

news_fetcher = Agent(
    name="news_fetcher",
    model="gemini-2.0-flash-exp",
    instruction="Отримайте топ новину для даної теми та верніть тільки цю новину.",
    output_key="news_data"     # Результат буде збережено в session.state["news_data"]
)

# Створюємо ParallelAgent для оркестрації під-агентів
data_gatherer = ParallelAgent(
    name="data_gatherer",
    sub_agents=[
        weather_fetcher,
        news_fetcher
    ]
)
```

Наданий сегмент коду ілюструє парадигму "Агент як інструмент" у межах Google ADK, що дозволяє агенту використовувати можливості іншого агента способом, аналогічним викликанню функції. Конкретно, код визначає систему генерування зображень, використовуючи класи LlmAgent та AgentTool від Google. Вона складається з двох агентів: батьківського artist_agent та під-агента image_generator_agent. Функція generate_image є простим інструментом, який імітує створення зображення, повертаючи мок-дані зображення. image_generator_agent відповідає за використання цього інструменту на основі текстового промпта, який він отримує. Роль artist_agent — спочатку придумати креативний промпт для зображення. Потім він викликає image_generator_agent через обгортку AgentTool. AgentTool діє як міст, дозволяючи одному агенту використовувати іншого агента як інструмент. Коли artist_agent викликає image_tool, AgentTool викликає image_generator_agent з промптом, придуманим художником. image_generator_agent потім використовує функцію generate_image з цим промптом. Нарешті, сгенероване зображення (або мок-дані) повертається назад через агентів. Ця архітектура демонструє багатошарову агентну систему, де агент високого рівня оркеструє спеціалізованого агента низького рівня для виконання завдання.

```python
from google.adk.agents import LlmAgent
from google.adk.tools import agent_tool
from google.genai import types


# 1. Простий функціональний інструмент для основної можливості.
# Це дотримується найкращої практики розділення дій від міркування.
def generate_image(prompt: str) -> dict:
    """
    Генерує зображення на основі текстового промпта.

    Args:
        prompt: Детальний опис зображення для генерування.

    Returns:
        Словник зі статусом та байтами сгенерованого зображення.
    """
    print(f"ІНСТРУМЕНТ: Генерування зображення для промпта: '{prompt}'")
    # У реальній реалізації це викликало б API генерування зображень.
    # Для цього прикладу ми повертаємо мок-дані зображення.
    mock_image_bytes = b"mock_image_data_for_a_cat_wearing_a_hat"
    return {
        "status": "success",
        # Інструмент повертає сирі байти, агент обробить створення Part.
        "image_bytes": mock_image_bytes,
        "mime_type": "image/png"
    }


# 2. Рефакторимо ImageGeneratorAgent у LlmAgent.
# Тепер він коректно використовує переданий вхід.
image_generator_agent = LlmAgent(
    name="ImageGen",
    model="gemini-2.0-flash",
    description="Генерує зображення на основі детального текстового промпта.",
    instruction=(
        "Ви спеціаліст з генерування зображень. Ваше завдання — взяти запит користувача "
        "та використати інструмент `generate_image` для створення зображення. "
        "Весь запит користувача повинен бути використаний як аргумент 'prompt' для інструменту. "
        "Після того як інструмент повернеме байти зображення, ви ПОВИННІ видати зображення."
    ),
    tools=[generate_image]
)

# 3. Обгортуємо виправленого агента в AgentTool.
# Опис тут — це те, що бачить батьківський агент.
image_tool = agent_tool.AgentTool(
    agent=image_generator_agent,
    description="Використовуйте цей інструмент для генерування зображення. Вхід повинен бути описовим промптом бажаного зображення."
)

# 4. Батьківський агент залишається незмінним. Його логіка була коректною.
artist_agent = LlmAgent(
    name="Artist",
    model="gemini-2.0-flash",
    instruction=(
        "Ви креативний художник. Спочатку придумайте креативний та описовий промпт для зображення. "
        "Потім використовуйте інструмент `ImageGen` для генерування зображення, використовуючи ваш промпт."
    ),
    tools=[image_tool]
)
```

## З першого погляду

**Що:** Складні проблеми часто перевищують можливості одного монолітного агента на основі LLM. Одиночний агент може не володіти різноманітними спеціалізованими навичками або доступом до специфічних інструментів, необхідних для розв'язання всіх частин багатогранного завдання. Це обмеження створює вузьке місце, знижуючи загальну ефективність та масштабованість системи. У результаті розв'язання складних завдань багатьох доменів стає неефективним та може призвести до неповних або субоптимальних результатів.

**Чому:** Паттерн Багатоагентного співробітництва пропонує стандартизоване рішення шляхом створення системи множинних співпрацюючих агентів. Складна проблема розбивається на менші, більш керовані підзавдання. Кожне підзавдання потім призначається спеціалізованому агенту з точними інструментами та можливостями, необхідними для його розв'язання. Ці агенти працюють разом через визначені протоколи комунікації та моделі взаємодії, такі як послідовні передачі, паралельні потоки роботи або ієрархічне делегування. Цей розподілений агентний підхід створює синергетичний ефект, дозволяючи групі досягти результатів, які були б неможливі для будь-якого окремого агента.

**Емпіричне правило:** Використовуйте цей паттерн, коли завдання занадто складне для одного агента та може бути декомпозовано на окремі підзавдання, що вимагають спеціалізованих навичок або інструментів. Він ідеальний для проблем, які виграють від різноманітної експертизи, паралельної обробки або структурованого робочого процесу з множинними етапами, таких як комплексні дослідження та аналіз, розробка програмного забезпечення або генерування креативного контенту.

**Візуальне резюме**

![][image3]

_Рис.3: Паттерн проектування Багатоагентного_

## Ключові висновки

- Багатоагентне співробітництво включає множинних агентів, що працюють разом для досягнення спільної мети.
- Цей паттерн використовує спеціалізовані ролі, розподілені завдання та міжагентну комунікацію.
- Співробітництво може приймати форми послідовних передач, паралельної обробки, дебатів або ієрархічних структур.
- Цей паттерн ідеальний для складних проблем, що вимагають різноманітної експертизи або множинних окремих етапів.

## Висновок

Цей розділ дослідив паттерн Багатоагентного співробітництва, демонструючи переваги оркестрації множинних спеціалізованих агентів у системах. Ми розглянули різні моделі співробітництва, підкреслюючи істотну роль паттерну в розв'язанні складних багатогранних проблем у різноманітних доменах. Розуміння агентного співробітництва природно веде до дослідження їх взаємодій з зовнішнім середовищем.

## Посилання

1. [Multi-Agent Collaboration Mechanisms: A Survey of LLMs](https://arxiv.org/abs/2501.06322)
2. [Multi-Agent System — The Power of Collaboration](https://aravindakumar.medium.com/introducing-multi-agent-frameworks-the-power-of-collaboration-e9db31bba1b6)

[image1]: ../Assets/chapter-7-image1.png
[image2]: ../Assets/chapter-7-image2.png
[image3]: ../Assets/chapter-7-image3.jpg

---

## Навігація

**Назад:** [Розділ 6. Планування](Розділ%206.%20Планування.md)<br>
**Вперед:** [Розділ 8. Управління пам'яттю](../Частина%202/Розділ%208.%20Управління%20пам'яттю.md)
