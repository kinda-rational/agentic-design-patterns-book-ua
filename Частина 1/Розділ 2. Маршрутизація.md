# Розділ 2: Маршрутизація

## Огляд паттерну «Маршрутизація»

Послідовна обробка через сцеплення промптів (prompt chaining) — фундаментальна техніка для детерміністичних лінійних робочих процесів з мовними моделями, однак її застосовність обмежена там, де вимагаються адаптивні відповіді. Реальні агентні системи часто повинні вибирати між кількома можливими діями залежно від зовнішніх обставин: стану середа, користувацького введення або результату попередньої операції. Ця здатність до динамічного прийняття рішень, що керує напрямком потоку до спеціалізованих функцій, інструментів або підпроцесів, досягається за допомогою механізму, відомого як маршрутизація.

Маршрутизація вводить у операційну структуру агента умовну логіку, переводячи його поведінку від фіксованого шляху виконання до моделі, де агент динамічно оцінює задані критерії та вибирає один із кількох можливих наступних кроків. Це забезпечує більш гнучке та контекстно-залежне поведінку системи.

Наприклад, агент для обробки користувацьких звернень, оснащений функцією маршрутизації, спочатку може класифікувати вхідний запит для визначення наміру користувача. На основі цієї класифікації він спрямує запит спеціалізованому агенту для прямої відповіді на запитання, інструменту вилучення з бази даних для інформації про рахунок або включить процедуру ескалації для складних випадків — замість використання одного заздалегідь заданого маршруту. Таким чином, більш розвинутий агент з маршрутизацією може:

1. Проаналізувати запит користувача.
2. **Маршрутизувати** запит за його _намірам_:
   - Якщо намір — «перевірити статус замовлення», спрямувати до під-агента або ланцюга інструментів, що взаємодіють з базою замовлень.
   - Якщо намір — «інформація про продукт», спрямувати до під-агента або ланцюга, що шукає в каталозі товарів.
   - Якщо намір — «технічна підтримка», спрямувати до іншого ланцюга, що використовує керівництва з усунення несправностей або ескалацію до людини.
   - Якщо намір неясний, спрямувати до під-агента уточнення або відповідного ланцюга промптів.

Ключовий компонент паттерну «Маршрутизація» — механізм, що виконує оцінку та керує потоком. Його можна реалізувати кількома способами:

- **Маршрутизація на базі LLM.** Сама мовна модель може бути запрошена проаналізувати вхід та видати конкретний ідентифікатор/інструкцію, що вказує на наступний крок або адресата. Наприклад: «Проаналізуй запит користувача та видай тільки категорію: 'Order Status', 'Product Info', 'Technical Support' або 'Other'». Система читає цю відповідь та спрямовує виконання відповідним чином.
- **Маршрутизація на основі вбудовувань.** Вхідний запит перекладається у векторне представлення (див. RAG, розділ 14), потім порівнюється з векторами, що відповідають різним маршрутам/можливостям. Запит спрямовується по маршруту з найбільшою семантичною близістю. Це корисно для семантичної маршрутизації, де рішення основується на сенсі, а не ключових словах.
- **Правил-орієнтована маршрутизація.** Використання заздалегідь заданих правил/логіки (if-else, switch), що базуються на ключових словах, паттернах або структурованих даних, витягнутих зі вхідних даних. Такий підхід швидший та детерміністичніший, ніж LLM-маршрутизація, але гірше узагальнює нові/тонкі випадки.
- **Маршрутизація на основі моделі машинного навчання.** Застосовується дискримінативна модель (класифікатор), спеціально навчена на невеликому розміченому корпусі для задачі маршрутизації. Хоча концептуально схожа на методи з вбудовуваннями, її відрізняє супервайз-дообучення, що записує логіку маршрутизації у ваги моделі. На відміну від LLM-підходу, рішення приймає не генеративна модель на інференсі, а заздалегідь дообучена задача-специфічна модель. LLM можуть використовуватися на етапі препроцесингу для синтетичного розширення датасету, але не беруть участь у прийнятті рішення в реальному часі.

Механізми маршрутизації можуть застосовуватися на різних етапах операційного циклу агента: на початку — для класифікації головної задачі; на проміжних кроках — для вибору наступної дії; всередині підпрограм — для вибору найбільш відповідного інструменту з набору.

Каркаси, як то LangChain, LangGraph та Google Agent Developer Kit (ADK), надають явні конструкції для описування та управління подібною умовною логікою. Завдяки архітектурі графа станів LangGraph особливо зручен для складної маршрутизації, де рішення залежать від накопленого стану системи. Аналогічно, ADK надає базові компоненти для структурування можливостей та моделей взаємодії агента, на яких будується логіка маршрутизації. У межах цих середовищ розробники визначають можливі операційні шляхи та функції/модельні оцінки, що задають переходи між вузлами обчислювального графа.

Реалізація маршрутизації дозволяє вийти за межи детерміністичної послідовної обробки. Вона підтримує побудову більш адаптивних потоків виконання, що реагують динамічно та доцільно на широкий спектр вхідних даних та змін стану.

## Практичні застосування та сценарії

Паттерн «Маршрутизація» — критично важливий механізм управління в адаптивних агентних системах: він дозволяє динамічно змінювати шлях виконання у відповідь на варіативні вхідні дані та внутрішні стани. Його користь охоплює багато доменів, забезпечуючи необхідний слій умовної логіки.

В HCI-сценаріях (віртуальні асистенти, ШІ-тьютори) маршрутизація використовується для інтерпретації намірів. Первинний аналіз природно-мовного запиту визначає наступну дію: виклик конкретного інструменту пошуку, ескалація до оператора або вибір наступного модуля навчальної програми, враховуючи прогрес користувача. Це виводить систему за межи лінійних діалогів та робить відповіді контекстними.

В автоматизованих конвеєрах обробки даних та документів маршрутизація виступає як функція класифікації та розподілу. Вхідні дані (листи, тикети, API-корисні навантаження) аналізуються за змістом, метаданими або форматом; далі елементи спрямовуються до відповідних робочих процесів: обробка лідів, специфічні трансформації для JSON/CSV, шлях терміново ї ескалації тощо.

У комплексних системах з численними інструментами/агентами маршрутизація діє як диспетчер верхнього рівня. Дослідницька система зі спеціалізованими агентами для пошуку, суммаризації та аналізу використовує роутер, щоб призначати задачі найбільш відповідному агенту під поточну мету. Аналогічно, ШІ-асистент програмування спочатку визначає мову та намір користувача — налагодження, пояснення, переведення — і лише потім передає фрагмент коду до відповідного спеціалізованого інструменту.

Врешті-решт, маршрутизація дає можливість логічного арбітражу, необхідного для створення функціонально різноманітних та контекстно-осведомлених систем. Агент перестає бути статичним виконавцем заздалегідь визначених послідовностей та стає динамічною системою, що приймає рішення про найбільш ефективний спосіб виконання задачі при змінюючихся умовах.

## Практичний приклад коду (LangChain)

Реалізація маршрутизації в коді передбачає визначення можливих шляхів та логіки вибору між ними. Фреймворки LangChain та LangGraph надають для цього спеціалізовані компоненти та структури. Граф станів LangGraph особливо наочний для візуалізації та реалізації маршрутизації.

Нижче показаний простий «агентоподібний» приклад на LangChain та Google Generative AI. Він створює «координатора», що маршрутизує користувацькі запити до симульованих «під-агентів» за намірам (бронювання, інформація, неясно). Система використовує мовну модель для класифікації запиту та делегує його відповідному обробнику, моделюючи базовий паттерн делегування, типовий для мультиагентних архітектур.

Спочатку встановіть необхідні бібліотеки:

```bash
pip install langchain langgraph google-cloud-aiplatform langchain-google-genai google-adk deprecated pydantic
```

Також потребуватиме налаштування оточення з API-ключем обраної моделі (наприклад, OpenAI, Google Gemini, Anthropic).

```python
# Copyright (c) 2025 Marco Fago
# https://www.linkedin.com/in/marco-fago/
#
# This code is licensed under the MIT License.
# See the LICENSE file in the repository for the full license text.

from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnablePassthrough, RunnableBranch

# --- Configuration ---
# Ensure your API key environment variable is set (e.g., GOOGLE_API_KEY)
try:
    llm = ChatGoogleGenerativeAI(model="gemini-2.5-flash", temperature=0)
    print(f"Language model initialized: {llm.model}")
except Exception as e:
    print(f"Error initializing language model: {e}")
    llm = None

# --- Define Simulated Sub-Agent Handlers (equivalent to ADK sub_agents) ---
def booking_handler(request: str) -> str:
    """Simulates the Booking Agent handling a request."""
    print("\n--- DELEGATING TO BOOKING HANDLER ---")
    return f"Booking Handler processed request: '{request}'. Result: Simulated booking action."

def info_handler(request: str) -> str:
    """Simulates the Info Agent handling a request."""
    print("\n--- DELEGATING TO INFO HANDLER ---")
    return f"Info Handler processed request: '{request}'. Result: Simulated information retrieval."

def unclear_handler(request: str) -> str:
    """Handles requests that couldn't be delegated."""
    print("\n--- HANDLING UNCLEAR REQUEST ---")
    return f"Coordinator could not delegate request: '{request}'. Please clarify."

# --- Define Coordinator Router Chain (equivalent to ADK coordinator's instruction) ---
# This chain decides which handler to delegate to.
coordinator_router_prompt = ChatPromptTemplate.from_messages([
    ("system", """Analyze the user's request and determine which specialist handler should process it.
     - If the request is related to booking flights or hotels,
        output 'booker'.
     - For all other general information questions, output 'info'.
     - If the request is unclear or doesn't fit either category,
        output 'unclear'.
     ONLY output one word: 'booker', 'info', or 'unclear'."""),
    ("user", "{request}")
])

if llm:
    coordinator_router_chain = coordinator_router_prompt | llm | StrOutputParser()

# --- Define the Delegation Logic (equivalent to ADK's Auto-Flow based on sub_agents) ---
# Use RunnableBranch to route based on the router chain's output.

# Define the branches for the RunnableBranch
branches = {
    "booker": RunnablePassthrough.assign(output=lambda x: booking_handler(x['request']['request'])),
    "info": RunnablePassthrough.assign(output=lambda x: info_handler(x['request']['request'])),
    "unclear": RunnablePassthrough.assign(output=lambda x: unclear_handler(x['request']['request'])),
}

# Create the RunnableBranch. It takes the output of the router chain
# and routes the original input ('request') to the corresponding handler.
delegation_branch = RunnableBranch(
    (lambda x: x['decision'].strip() == 'booker', branches["booker"]), # Added .strip()
    (lambda x: x['decision'].strip() == 'info', branches["info"]),     # Added .strip()
    branches["unclear"] # Default branch for 'unclear' or any other output
)

# Combine the router chain and the delegation branch into a single runnable
# The router chain's output ('decision') is passed along with the original input ('request')
# to the delegation_branch.
coordinator_agent = {
    "decision": coordinator_router_chain,
    "request": RunnablePassthrough()
} | delegation_branch | (lambda x: x['output']) # Extract the final output

# --- Example Usage ---
def main():
    if not llm:
        print("\nSkipping execution due to LLM initialization failure.")
        return

    print("--- Running with a booking request ---")
    request_a = "Book me a flight to London."
    result_a = coordinator_agent.invoke({"request": request_a})
    print(f"Final Result A: {result_a}")

    print("\n--- Running with an info request ---")
    request_b = "What is the capital of Italy?"
    result_b = coordinator_agent.invoke({"request": request_b})
    print(f"Final Result B: {result_b}")

    print("\n--- Running with an unclear request ---")
    request_c = "Tell me about quantum physics."
    result_c = coordinator_agent.invoke({"request": request_c})
    print(f"Final Result C: {result_c}")

if __name__ == "__main__":
    main()
```

Як відзначено вище, цей Python-код конструює простий «агентоподібний» контур з використанням LangChain та моделі Google Generative AI (gemini-2.5-flash). Визначені три симульовані обробнику: `booking_handler`, `info_handler` та `unclear_handler`, кожен призначений для певного рід запитів.

Ключовий компонент — `coordinator_router_chain`, що використовує `ChatPromptTemplate` для інструкції моделі: класифікувати вхідний запит в одну з категорій — 'booker', 'info' або 'unclear'. Вихід цієї ланцюга поступає в `RunnableBranch`, який делегує вихідний запит відповідній функції-обробнику. Об'єднаний `coordinator_agent` спочатку отримує рішення маршрутизатора, потім передає запит обраному обробнику та витягує кінцеву відповідь.

Функція `main` демонструє роботу на трьох прикладах, показуючи, як різні запити маршрутизуються та обробляються під-агентами. Додана обробка помилок ініціалізації мовної моделі.

## Практичний приклад коду (Google ADK)

Agent Development Kit (ADK) — фреймворк для інженерії агентних систем, що надає структуровану середу для визначення можливостей та поведінки агента. На відміну від архітектур явних обчислювальних графів, в ADK маршрутизація зазвичай реалізується через набір «інструментів», що представляють функції агента. Вибір відповідного інструменту за користувацьким запитом виконується внутрішньою логікою фреймворку, що використовує модель для зіставлення наміру з обробником.

Нижче наведений приклад застосування на Google ADK. Створюється агент-«Координатор», що маршрутизує запити користувачів до спеціалізованих під-агентів («Booker» для бронювань та «Info» для загальних відомостей) на основі заданих інструкцій. Під-агенти використовують інструменти для симуляції обробки запитів, демонструючи базовий паттерн делегування в агентній системі.

```python
# Copyright (c) 2025 Marco Fago
#
# This code is licensed under the MIT License.
# See the LICENSE file in the repository for the full license text.

import uuid
from typing import Dict, Any, Optional
from google.adk.agents import Agent
from google.adk.runners import InMemoryRunner
from google.adk.tools import FunctionTool
from google.genai import types
from google.adk.events import Event

# --- Define Tool Functions ---
# These functions simulate the actions of the specialist agents.
def booking_handler(request: str) -> str:
    """
    Handles booking requests for flights and hotels.
    Args:
        request: The user's request for a booking.
    Returns:
        A confirmation message that the booking was handled.
    """
    print("-------------------------- Booking Handler Called ----------------------------")
    return f"Booking action for '{request}' has been simulated."

def info_handler(request: str) -> str:
    """
    Handles general information requests.
    Args:
        request: The user's question.
    Returns:
        A message indicating the information request was handled.
    """
    print("-------------------------- Info Handler Called ----------------------------")
    return f"Information request for '{request}'. Result: Simulated information retrieval."

def unclear_handler(request: str) -> str:
    """Handles requests that couldn't be delegated."""
    return f"Coordinator could not delegate request: '{request}'. Please clarify."

# --- Create Tools from Functions ---
booking_tool = FunctionTool(booking_handler)
info_tool = FunctionTool(info_handler)

# Define specialized sub-agents equipped with their respective tools
booking_agent = Agent(
    name="Booker",
    model="gemini-2.0-flash",
    description="A specialized agent that handles all flight "
                "and hotel booking requests by calling the booking tool.",
    tools=[booking_tool]
)

info_agent = Agent(
    name="Info",
    model="gemini-2.0-flash",
    description="A specialized agent that provides general information "
                "and answers user questions by calling the info tool.",
    tools=[info_tool]
)

# Define the parent agent with explicit delegation instructions
coordinator = Agent(
    name="Coordinator",
    model="gemini-2.0-flash",
    instruction=(
        "You are the main coordinator. Your only task is to analyze "
        "incoming user requests "
        "and delegate them to the appropriate specialist agent. "
        "Do not try to answer the user directly.\n"
        "- For any requests related to booking flights or hotels, "
        "delegate to the 'Booker' agent.\n"
        "- For all other general information questions, delegate to the 'Info' agent."
    ),
    description="A coordinator that routes user requests to the "
                "correct specialist agent.",
    # The presence of sub_agents enables LLM-driven delegation (Auto-Flow) by default.
    sub_agents=[booking_agent, info_agent]
)

# --- Execution Logic ---
async def run_coordinator(runner: InMemoryRunner, request: str):
    """Runs the coordinator agent with a given request and delegates."""
    print(f"\n--- Running Coordinator with request: '{request}' ---")
    final_result = ""
    try:
        user_id = "user_123"
        session_id = str(uuid.uuid4())
        await runner.session_service.create_session(
            app_name=runner.app_name, user_id=user_id, session_id=session_id
        )
        for event in runner.run(
            user_id=user_id,
            session_id=session_id,
            new_message=types.Content(
                role='user',
                parts=[types.Part(text=request)]
            ),
        ):
            if event.is_final_response() and event.content:
                # Try to get text directly from event.content
                # to avoid iterating parts
                if hasattr(event.content, 'text') and event.content.text:
                    final_result = event.content.text
                elif event.content.parts:
                    # Fallback: Iterate through parts and extract text (might trigger warning)
                    text_parts = [part.text for part in event.content.parts if part.text]
                    final_result = "".join(text_parts)
                # Assuming the loop should break after the final response
                break
        print(f"Coordinator Final Response: {final_result}")
        return final_result
    except Exception as e:
        print(f"An error occurred while processing your request: {e}")
        return f"An error occurred while processing your request: {e}"

async def main():
    """Main function to run the ADK example."""
    print("--- Google ADK Routing Example (ADK Auto-Flow Style) ---")
    print("Note: This requires Google ADK installed and authenticated.")
    runner = InMemoryRunner(coordinator)

    # Example Usage
    result_a = await run_coordinator(runner, "Book me a hotel in Paris.")
    print(f"Final Output A: {result_a}")

    result_b = await run_coordinator(runner, "What is the highest mountain in the world?")
    print(f"Final Output B: {result_b}")

    result_c = await run_coordinator(runner, "Tell me a random fact.") # Should go to Info
    print(f"Final Output C: {result_c}")

    result_d = await run_coordinator(runner, "Find flights to Tokyo next month.") # Should go to Booker
    print(f"Final Output D: {result_d}")

if __name__ == "__main__":
    import nest_asyncio
    nest_asyncio.apply()
    await main()
```

Сценарій складається з головного агента-Координатора та двох спеціалізованих під-агентів: Booker та Info. Кожен під-агент оснащений `FunctionTool`, що обгортає Python-функцію, яка імітує дію. `booking_handler` імітує обробку бронювань, `info_handler` — вилучення загальних відомостей. `unclear_handler` служить запасним варіантом для випадків, коли делегування неможливо (у поточній логіці він явно не використовується при невдалому делегуванні).

Головна роль Координатора — аналізувати вхідні повідомлення та делегувати їх або Booker, або Info. Делегування автоматично реалізовано механізмом Auto-Flow в ADK, оскільки у Координатора визначені `sub_agents`. Функція `run_coordinator` створює `InMemoryRunner`, формує `user_id`/`session_id` та запускає обробку запиту через координатора. Метод `runner.run` видає події, з яких код вилучає кінцевий текст відповіді.

Функція `main` демонструє роботу на кількох прикладах, показуючи делегування запитів про бронювання агенту Booker, а інформаційних запитів — агенту Info.

## Коротко

**Що:** Агентні системи стикаються з широким спектром вхідних даних та ситуацій, які не укладаються в один лінійний процес. Проста послідовність не приймає рішень за контекстом. Без механізму вибору коректного інструменту або підпроцесу система залишається жорсткою та неадаптивною, що ускладнює побудову зрілих застосувань для реальних користувацьких запитів.

**Чому:** Паттерн «Маршрутизація» вводить у операційний каркас слой умовної логіки. Система спочатку аналізує вхідний запит, щоб визначити його природу/намір, потім динамічно спрямовує управління до відповідного спеціалізованого інструменту, функції або під-агента. Рішення може прийматися при допомозі LLM-промптів, заздалегідь заданих правил або семантичної близості вбудовувань. В результаті статичний заздалегідь визначений шлях перетворюється на гнучкий контекстно-осведомлений робочий процес, що вибирає найкращий наступний крок.

**Практичне правило:** Застосовуйте маршрутизацію, коли агент повинен вибирати між кількома різними робочими процесами, інструментами або під-агентами на основі користувацького введення або поточного стану. Це особливо важливо для систем, які повинні сортувати вхідні запити за типами завдань, наприклад чат-боти підтримки, що розрізняють запитання щодо продажів, технічної підтримки та управління рахунком.

#### Візуальне резюме

![][image1]
Рис. 1. Паттерн «Маршрутизація»: використання LLM у ролі маршрутизатора

## Ключові висновки

- Маршрутизація дозволяє агентам приймати динамічні рішення про наступний крок на основі умов.
- Вона дає можливість обробляти різноманітні вхідні дані та адаптувати поведінку, виходячи за межи лінійного виконання.
- Логіку маршрутизації можна реалізувати за допомогою LLM, правил або семантичної подібності вбудовувань.
- Фреймворки LangGraph та Google ADK надають структуровані способи визначення та управління маршрутизацією, хоча з різними архітектурними підходами.

## Висновок

Паттерн «Маршрутизація» — ключовий крок на шляху до по-справжньому динамічних та відзивчивих агентних систем. Реалізуючи маршрутизацію, ми виходимо за межи простих лінійних потоків та наділяємо агентів здатністю розумно вирішувати, як обробляти інформацію, відповідати на запити та використовувати доступні інструменти або під-агентів.

Ми побачили, як маршрутизація застосовна в різних доменах — від чат-ботів підтримки до конвеєрів обробки даних. Здатність аналізувати вхідні дані та умовно спрямовувати робочий процес — фундамент для агентів, що справляються з природною варіативністю реальних завдань.

Приклади на LangChain та Google ADK демонструють два різні, але ефективні підходи. Граф-орієнтований LangGraph забезпечує наочне явне визначення станів та переходів, що зручно для складних багатокрокових робочих процесів з розвинутою маршрутизацією. ADK, навпаки, фокусується на визначенні дискретних можливостей (інструментів) та покладається на здатність фреймворку спрямовувати запити до відповідних обробників — це простіше для агентів з чітко визначеним набором дій.

Оволодіння паттерном «Маршрутизація» необхідне для створення агентів, здатних розумно орієнтуватися в різних сценаріях та видавати адаптовані відповіді/дії залежно від контексту. Це ключовий компонент у побудові універсальних та надійних агентних застосувань.

## Посилання

1. [Документація LangGraph](https://www.langchain.com/)
2. [Документація Google Agent Developer Kit](https://google.github.io/adk-docs/)

[image1]: ../Assets/chapter-2-image1.jpg

---

## Навігація

**Назад:** [Розділ 1. Ланцюги промптів](Розділ%201.%20Ланцюги%20промптів.md)
**Вперед:** [Розділ 3. Паралелізація](Розділ%203.%20Паралелізація.md)
