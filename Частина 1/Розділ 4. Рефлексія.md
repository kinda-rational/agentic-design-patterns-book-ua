# Розділ 4: Рефлексія

## Огляд паттерну «Рефлексія»

У попередніх розділах ми розглянули базові агентні паттерни: «Ланцюги промптів» (Chaining) для послідовного виконання, «Маршрутизацію» (Routing) для динамічного вибору шляху та «Паралелізацію» (Parallelization) для конкурентного виконання. Ці паттерни дозволяють агентам виконувати складні завдання ефективніше та гнучче. Однак навіть при складній оркестрації початковий вихід або план агента може бути неоптимальним, неточним або неповним. Тут на сцену виходить паттерн «Рефлексія» (Reflection).

Паттерн «Рефлексія» передбачає, що Агент оцінює власну роботу, вихід або внутрішній стан та використовує цю оцінку для підвищення якості результату або уточнення відповіді. Це форма самокорекції та самополіпшення, що дозволяє агенту ітеративно поль馬ти вихід або коригувати підхід на основі зворотного зв'язку, внутрішньої критики або порівняння з заданими критеріями. Іноді рефлексія може виконуватися окремим агентом, чия роль — аналізувати вихід вихідного агента.

На відміну від простої послідовної ланцюга, де вихід напряму передається на наступний крок, або маршрутизації, яка вибирає шлях, рефлексія вводить контур зворотного зв'язку. Агент не просто видає відповідь; він потім розглядає цю відповідь (або процес, що породив її), виявляє потенційні проблеми та зони поліпшення та використовує ці інсайти, щоб створити поліпшену версію або підправити майбутні дії.

Типовий процес включає:

1. Виконання: агент виконує задачу або генерує первинний результат.
2. Оцінка/Критика: агент (часто через додатковий виклик LLM або набір правил) аналізує результат попереднього кроку. Оцінка може перевіряти фактичну коректність, зв'язність, стиль, повноту, відповідність інструкціям та інші релевантні критерії.
3. Рефлексія/Уточнення: на основі критики агент визначає, як поліпшити результат. Це може означати генерування нової, уточненої версії, налаштування параметрів для наступного кроку або навіть модифікацію загального плану.
4. Ітерація (необов'язково, але типово): уточнений результат або скоригований підхід потім виконується, і процес рефлексії може повторюватися, доки не буде досягнута задовільна якість або виконана умова зупинки.

Ключова та дуже ефективна реалізація паттерну «Рефлексія» розділяє процес на дві логічні ролі: «Продюсер» та «Критик». Це часто називають моделлю «Generator–Critic» або «Producer–Reviewer». Хоча один і той же Агент може виконувати саморефлексію, використання двох спеціалізованих агентів (або двох окремих викликів LLM з різними системними промптами) звичайно дає більш стійкі та менш упередженні результати.

1. Продюсер-агент: його основна задача — виконати первинну дію. Він повністю сфокусований на генеруванні контенту — чи то коду, чернетки статті або плану. Він приймає вихідний промпт та видає першу версію результату.

2. Критик-агент: його єдина мета — оцінити результат, згенерований Продюсером. Йому задають інший набір інструкцій, часто окрему «персону» (наприклад, «Ви — провідний інженер-програміст», «Ви — педантичний факт-чекер»). Ці інструкції спрямовують Критика на аналіз роботи Продюсера за заданими критеріями — фактична коректність, якість коду, стиль, повнота. Його задача — знайти недочети, запропонувати поліпшення та дати структурований зворотний зв'язок.

Таке розділення відповідальності цінне тим, що зменшує «когнітивну упередженість» самоперевірки. Критик підходить до висновку зі свіжої позиції, приділяючи увагу виключно пошуку помилок та зон поліпшення. Зворотний зв'язок від Критика передається назад Продюсеру та служить керівництвом для генерування нової, поліпшеної версії. Наведені приклади коду на LangChain та ADK реалізують саме цю двохагентну модель: у прикладі LangChain використовується спеціальний «reflector_prompt», що створює персону критика, а в прикладі ADK явно визначені два агенти — продюсер та рецензент.

Реалізація рефлексії звичайно вимагає включення контурів зворотного зв'язку в робочий процес агента. Це можна зробити через цикли в коді або при допомозі фреймворків, що підтримують управління станом та умовні переходи на основі результатів оцінки. Хоча єдиний крок «оцінка → уточнення» може бути реалізований в LangChain/LangGraph, ADK або Crew.AI, повнофункціональна ітеративна рефлексія чіше за все вимагає більш складної оркестрації.

Паттерн «Рефлексія» критично важливий для побудови агентів, здатних видавати високоякісні результати, розв'язувати тонкі завдання та проявляти елементи самосвідомості та адаптивності. Він переводить систему від простого виконання інструкцій до більш зрілого способу розв'язання проблем та генерування контенту.

Варто відзначити перетин рефлексії з постановкою цілей та моніторингом (див. розділ 11). Мета задає кінцевий еталон для самооцінки агента, а моніторинг відстежує прогрес. У багатьох практичних випадках рефлексія виступає в ролі коригуючого механізму, що використовує моніторингову зворотну інформацію для аналізу відхилень та коригування стратегії. Ця синергія перетворює агента з пасивного виконавця на цільову систему, що адаптивно працює на досягнення своїх задач.

Крім того, ефективність паттерну «Рефлексія» суттєво підвищується, коли LLM ведить пам'ять діалогу (див. розділ 8). Історія взаємодій забезпечує критичний контекст для етапу оцінки, дозволяючи агенту зіставляти результат не ізольовано, а на фоні попередніх репік, зворотного зв'язку та розвиваючихся цілей. Це допомагає вчитися на попередніх зауваженнях та не повторювати помилки. Без пам'яті кожна рефлексія — ізольована подія; з пам'яттю рефлексія стає накопичувальним процесом, де кожен цикл спирається на попередній, приводячи до більш розумного та контекстно-осведомленого уточнення.

## Практичні застосування та сценарії використання

Паттерн «Рефлексія» особливо корисний там, де критичні якість виходу, точність або дотримання складних обмежень:

1. Творче письмо та генерування контенту:
   Уточнення сгенерованого тексту, розповідей, віршів, маркетингових матеріалів.

   - Сценарій: агент пише блог-пост.
     - Рефлексія: створити чернетку, оцінити його на зв'язність, тон та ясність, потім переписати з урахуванням критики. Повторювати до досягнення потрібної якості.
     - Користь: більш виверений та ефективний контент.

2. Генерування та налагодження коду:
   Написання коду, пошук помилок та їх виправлення.

   - Сценарій: агент пише функцію на Python.
     - Рефлексія: написати ініціальну версію, запустити тести або статичний аналіз, виявити помилки/неефективності, потім змінити код на основі находок.
     - Користь: більш надійний та робочий код.

3. Розв'язання складних завдань:
   Оцінка проміжних кроків або запропонованих рішень у багатокрокових завданнях міркування.

   - Сценарій: агент розв'язує логічну головоломку.
     - Рефлексія: запропонувати крок, оцінити, наближає він до рішення або вводить суперечності; при необхідності откатиться та вибрати інший крок.
     - Користь: краща навігація по складному простору рішень.

4. Суммаризація та синтез інформації:
   Уточнення суммаризацій на точність, повноту та стислість.

   - Сценарій: агент суммирує довгий документ.
     - Рефлексія: сгенерувати первинну суммаризацію, порівняти з ключовими пунктами вихідника, доповнити недостаюче та поліпшити точність.
     - Користь: більш точні та повні суммаризації.

5. Планування та стратегія:
   Оцінка запропонованого плану та виявлення потенційних слабких місць.

   - Сценарій: агент планує серію кроків для досягнення мети.
     - Рефлексія: сгенерувати план, змоделювати його виконання або оцінити здійснюваність з урахуванням обмежень, доробити план за результатами.
     - Користь: більш ефективні та реалістичні плани.

6. Розмовні агенти:
   Ревізія попередніх ходів діалогу для утримання контексту, виправлення неправильних розумінь та підвищення якості відповіді.
   - Сценарій: чат-бот підтримки клієнтів.
     - Рефлексія: після відповіді користувача перегляньте історію діалогу та останнє генеровне повідомлення, щоб забезпечити зв'язність та коректно реагувати на новий вхід.
     - Користь: більш природні та ефективні розмови.

Рефлексія додає слой метакогніції в агентні системи, дозволяючи їм вчитися на своїх висновках та процесах та приводячи до більш розумних, надійних та якісних результатів.

## Практичний приклад коду (LangChain)

Реалізація повнофункціональної ітеративної рефлексії вимагає механізмів управління станом та циклічного виконання. Хоча в граф-фреймворках, як LangGraph, це підтримується нативно (або досягається у користувальницькому коді), принцип одного циклу рефлексії зручно показати при допомозі композиційного синтаксису LCEL (LangChain Expression Language).

Цей приклад реалізує рефлексивний цикл на базі бібліотеки LangChain та моделі OpenAI GPT-4o, ітеративно генеруючи та уточнюючи функцію на Python, що обчислює факторіал числа. Процес стартує з постановки задачі, генерує первинний код, а потім повторно рефлексирує на основі критики від симульованої ролі «старшого інженера-програміста», уточнюючи код на кожній ітерації, доки стадія критики не вирішить, що код ідеальний, або доки не буде досягнутий максимум ітерацій. Наприкінці скрипт друкує кінцевий уточнений код.

Спочатку встановіть необхідні бібліотеки:

```bash
pip install langchain langchain-community langchain-openai
```

Також потребуватиме налаштування оточення з API-ключем обраної моделі (наприклад, OpenAI, Google Gemini, Anthropic).

```python
import os
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.messages import SystemMessage, HumanMessage

# --- Configuration ---
# Load environment variables from .env file (for OPENAI_API_KEY)
load_dotenv()

# Check if the API key is set
if not os.getenv("OPENAI_API_KEY"):
    raise ValueError("OPENAI_API_KEY not found in .env file. Please add it.")

# Initialize the Chat LLM. We use gpt-4o for better reasoning.
# A lower temperature is used for more deterministic outputs.
llm = ChatOpenAI(model="gpt-4o", temperature=0.1)


def run_reflection_loop():
    """
    Demonstrates a multi-step AI reflection loop to progressively improve a Python function.
    """
    # --- The Core Task ---
    task_prompt = """
    Your task is to create a Python function named `calculate_factorial`.
    This function should do the following:
    1.  Accept a single integer `n` as input.
    2.  Calculate its factorial (n!).
    3.  Include a clear docstring explaining what the function does.
    4.  Handle edge cases: The factorial of 0 is 1.
    5.  Handle invalid input: Raise a ValueError if the input is a negative number.
    """

    # --- The Reflection Loop ---
    max_iterations = 3
    current_code = ""

    # We will build a conversation history to provide context in each step.
    message_history = [HumanMessage(content=task_prompt)]

    for i in range(max_iterations):
        print("\n" + "="*25 + f" REFLECTION LOOP: ITERATION {i + 1} " + "="*25)

        # --- 1. GENERATE / REFINE STAGE ---
        # In the first iteration, it generates. In subsequent iterations, it refines.
        if i == 0:
            print("\n>>> STAGE 1: GENERATING initial code...")
            # The first message is just the task prompt.
            response = llm.invoke(message_history)
            current_code = response.content
        else:
            print("\n>>> STAGE 1: REFINING code based on previous critique...")
            # The message history now contains the task,
            # the last code, and the last critique.
            # We instruct the model to apply the critiques.
            message_history.append(HumanMessage(
                content="Please refine the code using the critiques provided."
            ))
            response = llm.invoke(message_history)
            current_code = response.content

        print("\n--- Generated Code (v" + str(i + 1) + ") ---\n" + current_code)
        message_history.append(response)  # Add the generated code to history

        # --- 2. REFLECT STAGE ---
        print("\n>>> STAGE 2: REFLECTING on the generated code...")

        # Create a specific prompt for the reflector agent.
        # This asks the model to act as a senior code reviewer.
        reflector_prompt = [
            SystemMessage(content="""
                You are a senior software engineer and an expert
                 in Python.
                Your role is to perform a meticulous code review.
                Critically evaluate the provided Python code based
                 on the original task requirements.
                Look for bugs, style issues, missing edge cases,
                 and areas for improvement.
                If the code is perfect and meets all requirements,
                respond with the single phrase 'CODE_IS_PERFECT'.
                Otherwise, provide a bulleted list of your critiques.
            """),
            HumanMessage(content=f"Original Task:\n{task_prompt}\n\nCode to Review:\n{current_code}")
        ]

        critique_response = llm.invoke(reflector_prompt)
        critique = critique_response.content

        # --- 3. STOPPING CONDITION ---
        if "CODE_IS_PERFECT" in critique:
            print("\n--- Critique ---\nNo further critiques found. The code is satisfactory.")
            break

        print("\n--- Critique ---\n" + critique)

        # Add the critique to the history for the next refinement loop.
        message_history.append(HumanMessage(
            content=f"Critique of the previous code:\n{critique}"
        ))

    print("\n" + "="*30 + " FINAL RESULT " + "="*30)
    print("\nFinal refined code after the reflection process:\n")
    print(current_code)


if __name__ == "__main__":
    run_reflection_loop()
```

Код починається з налаштування оточення, завантаження API-ключів та ініціалізації потужної мовної моделі (наприклад, GPT-4o) з низькою температурою для більш сфокусованих висновків. Основна задача задається промптом — реалізувати функцію Python для обчислення факторіала, включаючи вимоги до docstring, обробці крайнього випадку (факторіал 0 дорівнює 1) та обробці помилкового введення (виняток ValueError при від'ємному числі). Функція run_reflection_loop організує ітеративний процес: на першій ітерації модель генерує код за завданням, на наступних — уточнює його за замітками з попереднього кроку. Окрема роль «рефлектора» (та ж модель, але з іншим системним промптом) виступає в ролі старшого інженера, що критикує код за вихідними вимогами. Якщо проблем немає, він відповідає «CODE_IS_PERFECT». Цикл продовжується до «ідеального» коду або досягнення ліміту ітерацій. Історія бесіди зберігається та передається моделі на кожному кроці, забезпечуючи контекст для генерування/уточнення та рефлексії. Наприкінці скрипт друкує останню версію коду.

## Практичний приклад коду (ADK)

Розглянемо концептуальний приклад на Google ADK. Він демонструє структуру Generator–Critic, де один компонент (Generator) виробляє первинний результат/план, а інший (Critic) дає критичний зворотний зв'язок, спрямовуючи Generator до більш точного та якісного кінцевого висновку.

```python
from google.adk.agents import SequentialAgent, LlmAgent

# The first agent generates the initial draft.
generator = LlmAgent(
    name="DraftWriter",
    description="Generates initial draft content on a given subject.",
    instruction="Write a short, informative paragraph about the user's subject.",
    output_key="draft_text"  # The output is saved to this state key.
)

# The second agent critiques the draft from the first agent.
reviewer = LlmAgent(
    name="FactChecker",
    description="Reviews a given text for factual accuracy and provides a structured critique.",
    instruction="""
    You are a meticulous fact-checker.
    1. Read the text provided in the state key 'draft_text'.
    2. Carefully verify the factual accuracy of all claims.
    3. Your final output must be a dictionary containing two keys:
       - "status": A string, either "ACCURATE" or "INACCURATE".
       - "reasoning": A string providing a clear explanation for your status, citing specific issues if any are found.
    """,
    output_key="review_output"  # The structured dictionary is saved here.
)

# The SequentialAgent ensures the generator runs before the reviewer.
review_pipeline = SequentialAgent(
    name="WriteAndReview_Pipeline",
    sub_agents=[generator, reviewer]
)

# Execution Flow:
# 1. generator runs -> saves its paragraph to state['draft_text'].
# 2. reviewer runs -> reads state['draft_text'] and saves its dictionary output to state['review_output'].
```

Цей код демонструє послідовний конвеєр агентів у Google ADK для генерування та рецензування тексту. Визначені два LlmAgent: генератор та рецензент. Генератор створює вихідний абзац по темі та зберігає його у стан за ключем draft_text. Рецензент виступає факт-чекером: читає текст з draft_text, перевіряє фактичну коректність, а на вихід видає словник зі статусом («ACCURATE»/«INACCURATE») та поясненням reasoning; результат зберігається за ключем review_output. SequentialAgent під назвою review_pipeline гарантує, що спочатку виконається генератор, потім рецензент. Загальний потік: генератор виробляє текст та зберігає його; потім рецензент читає цей текст зі стану, перевіряє та зберігає структурований вихід. Примітка: доступна й альтернативна реалізація з використанням LoopAgent в ADK.

Перед завершенням важливо враховувати, що хоча паттерн «Рефлексія» суттєво підвищує якість висновку, у нього є компроміси. Ітеративність, хоч і потужна, підвищує вартість та затримку, оскільки кожне уточнення вимагає нового виклику LLM, що робить паттерн не завжди підходящим для чутливих до часу застосувань. Крім того, паттерн вимогливий до пам'яті; на кожній ітерації зростає історія спілкування — вихідний результат, критика, наступні поліпшення.

## Коротко

**Що:** Початковий вихід агента часто субоптимальний — з неточностями, неповнотою або недотриманням складних обмежень. Базові агентні робочі процеси не містять вбудованого механізму, що дозволяє агенту розпізнати та виправити власні помилки. Це розв'язується за рахунок того, що агент оцінює свою роботу сам або, що надійніше, з залученням окремого критика-агента, завдяки чому вихідна відповідь не стає кінцевою незалежно від її якості.

**Чому:** Паттерн «Рефлексія» вводить механізм самокорекції та уточнення. Він організує контур зворотного зв'язку, де «продюсер» генерує вихід, потім «критик» оцінює його за заданими критеріями. Критика використовується для генерування поліпшеної версії. Ітеративний цикл «генерування → оцінка → уточнення» поступово підвищує якість результату, поліпшуючи точність, зв'язність та надійність.

**Практичне правило:** Застосовуйте паттерн «Рефлексія», коли якість, точність та детальність кінцевого результату важливіші за швидкість та вартість. Особливо ефективний для завдань як то підготовка виверених довгих контентів, написання та налагодження коду, складання детальних планів. Використовуйте окремого критика-агента, коли потрібна висока об'єктивність або спеціалізована оцінка, яку може упустити універсальний продюсер-агент.

**Візуальне резюме**

![][image1]
Рис. 1. Паттерн «Рефлексія», саморефлексія

![][image2]
Рис. 2. Паттерн «Рефлексія»: продюсер та агент-критик

## Ключові висновки

- **Головна перевага**: ітеративна самокорекція та уточнення виходів, що приводить до значно вищої якості, точності та відповідності складним інструкціям.
- **Структура**: контур «виконання → оцінка/критика → уточнення». Паттерн необхідний там, де потрібні висока якість, точність та нюансованість.
- **Сильна реалізація**: модель «Продюсер–Критик», де окремий агент (або роль) оцінює вихідний результат. Розділення ролей підвищує об'єктивність та дозволяє отримати спеціалізований структурований зворотний зв'язок.
- **Компроміси**: ріст затримок та обчислювальних витрат; ризик перевищити контекстне вікно моделі або потрапити під обмеження постачальника API.
- **Реалізація**: повнофункціональна ітеративна рефлексія вимагає управління станом (наприклад, LangGraph), але один цикл можна зібрати в LangChain з LCEL, передавши вихід на критику та наступне уточнення.
- **ADK**: підтримує рефлексію через послідовні робочі процеси, де вихід одного агента критикується іншим з наступним уточненням.
- **Ефект**: агент вчиться самокорекції та підвищує результати з часом.

## Висновок

Паттерн «Рефлексія» дає важливий механізм самокорекції в робочому процесі агента, забезпечуючи ітеративне поліпшення замість однопрохідного виконання. Це досягається контуром, у якому система генерує результат, оцінює його за конкретними критеріями та використовує цю оцінку для створення уточненого висновку. Оцінка може виконуватися самим агентом (саморефлексія) або — що часто ефективніше — окремим критиком-агентом, що є ключовим архітектурним рішенням усередину паттерну.

Хоча повністю автономний багатокроковий процес рефлексії вимагає надійної архітектури управління станом, його ядро наочно демонструється в одному циклі «генерування — критика — уточнення». Як керуюча структура, рефлексія добре комбінується з іншими базовими паттернами, допомагаючи будувати більш стійкі та функціонально складні агентні системи.

## Посилання

Нижче наведені ресурси для подальшого прочитання про паттерн «Рефлексія» та суміжні концепції:

1. [Training Language Models to Self-Correct via Reinforcement Learning](https://arxiv.org/abs/2409.12917)
2. [Документація LangChain Expression Language (LCEL)](https://python.langchain.com/docs/introduction/)
3. [Документація LangGraph](https://www.langchain.com/langgraph)
4. [Документація Google Agent Developer Kit (ADK) (Multi‑Agent Systems)](https://google.github.io/adk-docs/agents/multi-agents/)

[image1]: ../Assets/chapter-4-image1.png
[image2]: ../Assets/chapter-4-image2.png

---

## Навігація

**Назад:** [Розділ 3. Паралелізація](Розділ%203.%20Паралелізація.md)
**Вперед:** [Розділ 5. Використання інструментів](Розділ%205.%20Використання%20інструментів.md)
