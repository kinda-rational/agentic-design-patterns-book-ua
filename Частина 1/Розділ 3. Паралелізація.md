# Розділ 3: Паралелізація

## Огляд паттерну «Паралелізація»

У попередніх розділах ми розглянули «Сцеплення промптів» (Prompt Chaining) для послідовних робочих процесів та «Маршрутизацію» для динамічного вибору та переходів між різними шляхами. Хоча ці паттерни важливі, багато складних агентних завдань складаються з кількох підзадач, які можна виконувати одночасно, а не суворо одна за одною. Саме тут стає критично важливим паттерн «Паралелізація».

Паралелізація — це одночасне виконання кількох компонентів, таких як виклики LLM, використання інструментів або навіть цілих під-агентів (див. рис. 1). Замість очікування завершення одного кроку перед початком наступного, паралельне виконання дозволяє незалежним завданням запускатися в один і той же час, що суттєво скорочує загальний час виконання для завдань, розкладиних на незалежні частини.

Розглянемо агента, призначеного для дослідження теми та суммаризації знайденого. Послідовний підхід може виглядати так:

1. Знайти джерело A.
2. Підсумувати джерело A.
3. Знайти джерело B.
4. Підсумувати джерело B.
5. Синтезувати кінцеву відповідь із суммаризацій A та B.

Паралельний підхід замість цього міг би:

1. Шукати джерело A та шукати джерело B одночасно.
2. Як тільки обидва пошуки завершені, підсумувати джерело A та підсумувати джерело B одночасно.
3. Синтезувати кінцеву відповідь із суммаризацій A та B (зазвичай цей крок послідовний та чекає завершення паралельних кроків).

Ключова ідея — виявляти частини робочого процесу, які не залежать від результатів інших частин, та виконувати їх паралельно. Це особливо ефективно при роботі з зовнішніми сервісами (наприклад, API або базами даних), де є затримки: можна розсилати кілька запитів одночасно.

Реалізація паралелізації часто вимагає фреймворків з підтримкою асинхронного виконання або багатопоточності/багатопроцесності. Сучасні агентні фреймворки спроектовані з урахуванням асинхронних операцій та дозволяють легко визначати кроки, які можуть виконуватися паралельно.

![][image2]
Рис. 1. Приклад паралелізації з під-агентами

Такі фреймворки, як LangChain, LangGraph та Google ADK, надають механізми для паралельного виконання. У LangChain Expression Language (LCEL) паралельне виконання досягається за рахунок комбінування runnable-об'єктів за допомогою операторів як то | (для послідовності) та структурування ланцюгів або графів так, щоб гілки виконувалися одночасно. LangGraph, завдяки графовій структурі, дозволяє визначати кілька вузлів, запущених з одного стану, що фактично включає паралельні гілки в робочому процесі. Google ADK надає вбудовані механізми для спрощення та управління паралельним виконанням агентів, що суттєво підвищує ефективність та масштабованість складних мультиагентних систем. Ця нативна можливість дозволяє розробникам проектувати рішення, де кілька агентів працюють одночасно, а не послідовно.

Паттерн «Паралелізація» жизненно важливий для підвищення ефективності та відзивчивості агентних систем, особливо при виконанні завдань, що включають безліч незалежних пошуків, обчислень або взаємодій із зовнішніми сервісами. Це ключова техніка оптимізації продуктивності складних агентних робочих процесів.

## Практичні застосування та сценарії

Паралелізація — потужний паттерн оптимізації продуктивності агентів у безлічі застосувань:

1. Збір інформації та дослідження.

   - Приклад: агент, що досліджує компанію.
   - Паралельні завдання: пошук новин, отримання біржових даних, моніторинг згадування у соціальних мережах та запит до внутрішної бази компанії — все одночасно.
   - Користь: формування цілісної картини швидше, ніж при послідовних зверненнях.

2. Обробка даних та аналітика.

   - Приклад: агент, що аналізує відгуки клієнтів.
   - Паралельні завдання: аналіз тональності, вилучення ключових слів, категоризація відгуків, виявлення терміних проблем — одночасно з пакетом даних.
   - Користь: різноаспектна аналітика швидше.

3. Взаємодія з кількома API або інструментами.

   - Приклад: агент планування подорожей.
   - Паралельні завдання: перевірити ціни на авіаквитки, наявність готелів, місцеві події та рекомендації ресторанів — одночасно.
   - Користь: швидкий та повний план подорожі.

4. Генерування контенту з кількох компонентів.

   - Приклад: агент, що створює маркетингове повідомлення.
   - Паралельні завдання: генерувати тему, чернетку повідомлення, підібрати зображення та текст для кнопки CTA — одночасно.
   - Користь: швидше зібрати фінальний матеріал.

5. Валідація та перевірка.

   - Приклад: агент перевіряє користувацький вхід.
   - Паралельні завдання: перевірити формат email, валідувати телефон, звірити адресу з базою, перевірити на ненормативну лексику — одночасно.
   - Користь: прискорена зворотна інформація про коректність.

6. Мультимодальна обробка.

   - Приклад: агент аналізує пост у соціальній мережі з текстом та зображенням.
   - Паралельні завдання: аналіз тексту на тональність та ключові слова та паралельний аналіз зображення на об'єкти та сцену.
   - Користь: швидше об'єднання інсайтів із різних модальностей.

7. A/B-тестування або генерування кількох варіантів.
   - Приклад: агент генерує творчі текстові варіанти.
   - Паралельні завдання: генерувати три різні заголовки статті одночасно з дещо різними промптами або моделями.
   - Користь: швидкий порівняльний відбір найкращого варіанту.

Паралелізація — базова техніка оптимізації в агентному дизайні: вона дозволяє створювати більш продуктивні та відзивчиві застосування, використовуючи конкурентне виконання незалежних завдань.

## Практичний приклад коду (LangChain)

Паралельне виконання в LangChain здійснюється за допомогою LangChain Expression Language (LCEL). Основний метод — структурувати кілька runnable-компонентів у словник або список. Коли ця колекція подається на вхід наступного компонента ланцюга, рантайм LCEL виконує вміщені runnables одночасно.

У контексту LangGraph цей принцип реалізується через топологію графа. Паралельні робочі процеси визначаються як безліч вузлів без прямих послідовних залежностей, запущених з одного загального вузла. Ці паралельні гілки виконуються незалежно, перш ніж їхні результати будуть агреговані на наступному вузлі-конвергенції.

Нижче показана реалізація паралельного процесу на LangChain. Цей робочий процес запускає дві незалежні операції паралельно у відповідь на єдиний користувацький запит. Паралельні процеси оформлені як окремі ланцюги/функції, а їхні виходи потім агреговані в єдиний результат.

Для запуску потребуються Python-пакети langchain, langchain-community та постачальник моделі, наприклад langchain-openai. Крім того, у локальному середовищі повинен бути налаштований коректний API-ключ обраної моделі.

```python
import os
import asyncio
from typing import Optional
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import Runnable, RunnableParallel, RunnablePassthrough

# --- Configuration ---
# Ensure your API key environment variable is set (e.g., OPENAI_API_KEY)
try:
    llm: Optional[ChatOpenAI] = ChatOpenAI(model="gpt-4o-mini", temperature=0.7)
except Exception as e:
    print(f"Error initializing language model: {e}")
    llm = None

# --- Define Independent Chains ---
# These three chains represent distinct tasks that can be executed in parallel.
summarize_chain: Runnable = (
    ChatPromptTemplate.from_messages([
        ("system", "Summarize the following topic concisely:"),
        ("user", "{topic}")
    ])
    | llm
    | StrOutputParser()
)

questions_chain: Runnable = (
    ChatPromptTemplate.from_messages([
        ("system", "Generate three interesting questions about the following topic:"),
        ("user", "{topic}")
    ])
    | llm
    | StrOutputParser()
)

terms_chain: Runnable = (
    ChatPromptTemplate.from_messages([
        ("system", "Identify 5-10 key terms from the following topic, separated by commas:"),
        ("user", "{topic}")
    ])
    | llm
    | StrOutputParser()
)

# --- Build the Parallel + Synthesis Chain ---
# 1. Define the block of tasks to run in parallel. The results of these,
#    along with the original topic, will be fed into the next step.
map_chain = RunnableParallel(
    {
        "summary": summarize_chain,
        "questions": questions_chain,
        "key_terms": terms_chain,
        "topic": RunnablePassthrough(),  # Pass the original topic through
    }
)

# 2. Define the final synthesis prompt which will combine the parallel results.
synthesis_prompt = ChatPromptTemplate.from_messages([
    ("system", """Based on the following information:
    Summary: {summary}
    Related Questions: {questions}
    Key Terms: {key_terms}
    Synthesize a comprehensive answer."""),
    ("user", "Original topic: {topic}")
])

# 3. Construct the full chain by piping the parallel results directly
#    into the synthesis prompt, followed by the LLM and output parser.
full_parallel_chain = map_chain | synthesis_prompt | llm | StrOutputParser()


# --- Run the Chain ---
async def run_parallel_example(topic: str) -> None:
    """
    Asynchronously invokes the parallel processing chain with a specific topic
    and prints the synthesized result.
    Args:
        topic: The input topic to be processed by the LangChain chains.
    """
    if not llm:
        print("LLM not initialized. Cannot run example.")
        return

    print(f"\n--- Running Parallel LangChain Example for Topic: '{topic}' ---")
    try:
        # The input to `ainvoke` is the single 'topic' string,
        # then passed to each runnable in the `map_chain`.
        response = await full_parallel_chain.ainvoke(topic)
        print("\n--- Final Response ---")
        print(response)
    except Exception as e:
        print(f"\nAn error occurred during chain execution: {e}")


if __name__ == "__main__":
    test_topic = "The history of space exploration"
    # In Python 3.7+, asyncio.run is the standard way to run an async function.
    asyncio.run(run_parallel_example(test_topic))
```

Наведений Python-код реалізує застосування на LangChain для ефективної обробки теми за рахунок паралельного виконання. Зверніть увагу, що asyncio забезпечує конкурентність, а не справжній паралелізм: на одному потоці перемикання завдань відбувається під час очікування (наприклад, мережевих запитів). В результаті створюється ефект одночасного прогресу кількох завдань, але виконання коду продовжує обмежуватися одним потоком та GIL.

Код імпортує ключові компоненти з langchain_openai та langchain_core: моделі, промпти, парсери та структури runnable. Намагається ініціалізувати ChatOpenAI (модель «gpt-4o-mini») з заданою температурою; обертає ініціалізацію в try/except. Далі визначаються три незалежні «ланцюги»: коротка суммаризація теми, генерування трьох запитань по темі та вилучення 5–10 ключових термінів (через відповідні ChatPromptTemplate, модель та StrOutputParser).

Потім конструюється блок RunnableParallel, що об'єднує три ланцюги та пропускає вихідну тему через RunnablePassthrough. Визначається окремий промпт синтезу, який приймає суммаризацію, запитання, ключові терміни та оригінальну тему, щоб генерувати кінцеву відповідь. Повна ланцюг будується як послідовність: паралельний блок → промпт синтезу → модель → парсер рядка. Асинхронна функція run_parallel_example демонструє виклик повної ланцюга. Наприкінці приклад запускається для теми «The history of space exploration».

## Практичний приклад коду (Google ADK)

Тепер розглянемо конкретний приклад цих ідей у межах Google ADK. Розберемо, як примітиви ADK — такі як ParallelAgent та SequentialAgent — застосовуються для побудови потоку агента, що використовує конкурентне виконання для повищення ефективності.

```python
from google.adk.agents import LlmAgent, ParallelAgent, SequentialAgent
from google.adk.tools import google_search

GEMINI_MODEL = "gemini-2.0-flash"

# --- 1. Define Researcher Sub-Agents (to run in parallel) ---
# Researcher 1: Renewable Energy
researcher_agent_1 = LlmAgent(
    name="RenewableEnergyResearcher",
    model=GEMINI_MODEL,
    instruction="""You are an AI Research Assistant specializing in energy.
    Research the latest advancements in 'renewable energy sources'.
    Use the Google Search tool provided. Summarize your key findings
    concisely (1-2 sentences). Output *only* the summary.""",
    description="Researches renewable energy sources.",
    tools=[google_search],
    # Store result in state for the merger agent
    output_key="renewable_energy_result"
)

# Researcher 2: Electric Vehicles
researcher_agent_2 = LlmAgent(
    name="EVResearcher",
    model=GEMINI_MODEL,
    instruction="""You are an AI Research Assistant specializing in transportation.
    Research the latest developments in 'electric vehicle technology'.
    Use the Google Search tool provided. Summarize your key findings
    concisely (1-2 sentences). Output *only* the summary.""",
    description="Researches electric vehicle technology.",
    tools=[google_search],
    # Store result in state for the merger agent
    output_key="ev_technology_result"
)

# Researcher 3: Carbon Capture
researcher_agent_3 = LlmAgent(
    name="CarbonCaptureResearcher",
    model=GEMINI_MODEL,
    instruction="""You are an AI Research Assistant specializing in climate solutions.
    Research the current state of 'carbon capture methods'.
    Use the Google Search tool provided. Summarize your key findings
    concisely (1-2 sentences). Output *only* the summary.""",
    description="Researches carbon capture methods.",
    tools=[google_search],
    # Store result in state for the merger agent
    output_key="carbon_capture_result"
)

# --- 2. Create the ParallelAgent (Runs researchers concurrently) ---
# This agent orchestrates the concurrent execution of the researchers.
# It finishes once all researchers have completed and stored their results in state.
parallel_research_agent = ParallelAgent(
    name="ParallelWebResearchAgent",
    sub_agents=[researcher_agent_1, researcher_agent_2, researcher_agent_3],
    description="Runs multiple research agents in parallel to gather information."
)

# --- 3. Define the Merger Agent (Runs *after* the parallel agents) ---
# This agent takes the results stored in the session state by the parallel agents
# and synthesizes them into a single, structured response with attributions.
merger_agent = LlmAgent(
    name="SynthesisAgent",
    model=GEMINI_MODEL,  # Or potentially a more powerful model if needed for synthesis
    instruction="""You are an AI Assistant responsible for combining research findings
    into a structured report. Your primary task is to synthesize the following research
    summaries, clearly attributing findings to their source areas. Structure your response
    using headings for each topic. Ensure the report is coherent and integrates the key
    points smoothly.

    **Crucially: Your entire response MUST be grounded *exclusively* on the information
    provided in the 'Input Summaries' below. Do NOT add any external knowledge, facts,
    or details not present in these specific summaries.**

    **Input Summaries:**
    *   **Renewable Energy:**
        {renewable_energy_result}
    *   **Electric Vehicles:**
        {ev_technology_result}
    *   **Carbon Capture:**
        {carbon_capture_result}

    **Output Format:**
    ## Summary of Recent Sustainable Technology Advancements

    ### Renewable Energy Findings (Based on RenewableEnergyResearcher's findings)
    [Synthesize and elaborate *only* on the renewable energy input summary provided above.]

    ### Electric Vehicle Findings (Based on EVResearcher's findings)
    [Synthesize and elaborate *only* on the EV input summary provided above.]

    ### Carbon Capture Findings (Based on CarbonCaptureResearcher's findings)
    [Synthesize and elaborate *only* on the carbon capture input summary provided above.]

    ### Overall Conclusion
    [Provide a brief (1-2 sentence) concluding statement that connects *only* the
    findings presented above.]

    Output *only* the structured report following this format. Do not include
    introductory or concluding phrases outside this structure, and strictly
    adhere to using only the provided input summary content.""",
    description="Combines research findings from parallel agents into a structured, "
                "cited report, strictly grounded on provided inputs.",
    # No tools needed for merging
    # No output_key needed here, as its direct response is the final output of the sequence
)

# --- 4. Create the SequentialAgent (Orchestrates the overall flow) ---
# This is the main agent that will be run. It first executes the ParallelAgent
# to populate the state, and then executes the MergerAgent to produce the final output.
sequential_pipeline_agent = SequentialAgent(
    name="ResearchAndSynthesisPipeline",
    # Run parallel research first, then merge
    sub_agents=[parallel_research_agent, merger_agent],
    description="Coordinates parallel research and synthesizes the results."
)

root_agent = sequential_pipeline_agent
```

Цей код визначає мультиагентну систему для дослідження та синтезу відомостей про стійкі технології. Створюються три LlmAgent-дослідника: по відновлюваній енергетиці, електротранспорту та методам уловлювання CO₂. Кожен використовує інструмент `google_search`, суммаризує підсумок у 1–2 реченнях та зберігає результат у стан з ключем.

Потім створюється ParallelAgent, який запускає трьох дослідників паралельно та завершується після того, як вони зберегтимуть дані у стан. Далі визначається MergerAgent (також LlmAgent) — він бере суммаризації зі стану та синтезує структурований звіт. Інструкція наголошує суворе заземлення на вхідних суммаризаціях без додавання зовнішніх фактів. Нарешті, SequentialAgent оркеструє загальний потік: спочатку виконується паралельний збір, потім — синтез звіту.

## Коротко

**Що:** У багатьох агентних робочих процесах є кілька підзадач, які потрібно виконати для досягнення кінцевої мети. Суто послідовне виконання, при якому кожен крок чекає завершення попереднього, часто неефективно та повільно. Особливо це гальмує, коли завдання залежать від зовнішнього I/O (API, БД): без конкурентного виконання сумарний час стає сумою тривалостей всіх кроків.

**Чому:** Паттерн «Паралелізація» дає стандартний спосіб одночасно виконувати незалежні завдання. Він виявляє компоненти робочого процесу (виклики інструментів або LLM), результати яких не залежать один від одного. Фреймворки як LangChain та Google ADK надають вбудовані конструкції для декларування та управління такими паралельними операціями. Запускаючи незалежні завдання одночасно, а не послідовно, цей паттерн суттєво зменшує загальну затримку.

**Практичне правило:** Використовуйте паралелізацію, коли в робочому процесі є кілька незалежних операцій, які можна запускати одночасно, наприклад: запити до кількох API, обробка різних фрагментів даних або генерування кількох компонентів контенту для подальшого синтезу.

**![][image1]**

Рис. 2. Паттерн «Паралелізація»

## Ключові висновки

- Паралелізація — це одночасне виконання незалежних завдань для підвищення ефективності.
- Особливо корисна, коли завдання чекають зовнішні ресурси (API-виклики, I/O).
- Перехід до конкурентної/паралельної архітектури підвищує складність та вартість (дизайн, налагодження, логування).
- Фреймворки LangChain та Google ADK підтримують визначення та управління паралельним виконанням.
- В LCEL ключова конструкція для паралелі — RunnableParallel.
- В Google ADK паралель можна реалізувати через LLM-керовану делегацію: координатор виявляє незалежні підзадачі та запускає їх спеціалізованими під-агентами.
- Паралелізація зменшує сумарну затримку та робить агентні системи більш відзивчивими при складних завданнях.

## Висновок

Паттерн паралелізації — спосіб оптимізації обчислювальних робочих процесів за рахунок одночасного виконання незалежних підзадач. Такий підхід зменшує сумарну затримку, особливо в сценаріях з кількома інференсами моделей або викликами зовнішніх сервісів.

Фреймворки надають різні механізми реалізації. В LangChain конструкція RunnableParallel дозволяє явно визначити та виконати кілька ланцюгів одночасно. У Google Agent Developer Kit (ADK) паралель досягається через мультиагентну делегацію: координатор назначає підзадачі спеціалізованим агентам, які можуть працювати паралельно.

Комбінуючи паралельну обробку з послідовними (chaining) та умовними (routing) потоками, можна будувати складні та високопродуктивні обчислювальні системи, що ефективно справляються з різноманітними та комплексними завданнями.

## Посилання

1. [Документація LCEL (паралелізм)](https://python.langchain.com/docs/concepts/lcel/)
2. [Документація Google ADK (мультиагентні системи)](https://google.github.io/adk-docs/agents/multi-agents/)
3. [Документація Python asyncio](https://docs.python.org/3/library/asyncio.html)

[image1]: ../Assets/chapter-3-image1.jpg
[image2]: ../Assets/chapter-3-image2.png

---

## Навігація

**Назад:** [Розділ 2. Маршрутизація](Розділ%202.%20Маршрутизація.md)<br>
**Вперед:** [Розділ 4. Рефлексія](Розділ%204.%20Рефлексія.md)
